From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Sat, 21 Sep 2019 00:44:19 -0700
Subject: [PATCH] Per player view distance implementation

This patch implements CraftPlayer#setViewDistance and
CraftPlayer#getViewDistance

This patch replaces the existing system to handle player tickets
and chunk sending to players.
 Most of the work is pulled by two
PlayerAreaMap's controlling: a radius for sending chunks and a radius
for adding player tickets. Currently the difference between the two
radii is just 1.
Normal vanilla has a difference of two, but this
causes issues where outer chunks in the view distance sometimes
do not send. This is because the outer radius is not guaranteed to
be at ticket level 32, which is required to be sent to players.

The ticket manager in ChunkMapDistance for players is no longer used and
is entirely replaced by the ticket distance map. The ticket tracker also
adds a configurable chunk load rate per player.

This patch moves the order of the distance map update in movePlayer
until after a client is sent a center section packet. This is required
to avoid the client rejecting chunks it receives when teleporting.

diff --git a/src/main/java/com/tuinity/tuinity/config/TuinityConfig.java b/src/main/java/com/tuinity/tuinity/config/TuinityConfig.java
index b9d69efd0ed3cba9b7c9ae36e79e0387958fc1f5..a541e9e87f8d56a6fd228e0e806a633090f6fa11 100644
--- a/src/main/java/com/tuinity/tuinity/config/TuinityConfig.java
+++ b/src/main/java/com/tuinity/tuinity/config/TuinityConfig.java
@@ -118,6 +118,45 @@ public final class TuinityConfig {
         tickThreads = TuinityConfig.getInt("server-tick-threads", 1); // will be 4 in the future
     }*/
 
+    public static double maxChunkSendsPerPlayer; // per second
+
+    public static int[] maxChunkSendsPerPlayerChoice = new int[100];
+
+    private static void maxChunkLoadsPerPlayer() {
+        if (TuinityConfig.configVersion < 1) {
+            TuinityConfig.set("max-pending-chunk-tickets-per-player", null);
+        }
+        maxChunkSendsPerPlayer = TuinityConfig.getDouble("target-chunk-sends-per-player-per-second", 40.0);
+        if (maxChunkSendsPerPlayer <= -1.0) {
+            maxChunkSendsPerPlayer = Integer.MAX_VALUE;
+        } else if (maxChunkSendsPerPlayer <= 1.0) {
+            maxChunkSendsPerPlayer = 1.0;
+        } else if (maxChunkSendsPerPlayer > Integer.MAX_VALUE) {
+            maxChunkSendsPerPlayer = Integer.MAX_VALUE;
+        }
+
+        double rateTick = maxChunkSendsPerPlayer / 20.0;
+        double a = Math.floor(rateTick);
+        double b = Math.ceil(rateTick);
+
+        // we want to spread out a and b over the interval so it's smooth
+
+        int aInt = (int)a;
+        int bInt = (int)b;
+        double total = b;
+        maxChunkSendsPerPlayerChoice[0] = bInt;
+
+        for (int i = 1, len = maxChunkSendsPerPlayerChoice.length; i < len; ++i) {
+            if (total / (double)i >= rateTick) {
+                total += a;
+                maxChunkSendsPerPlayerChoice[i] = aInt;
+            } else {
+                total += b;
+                maxChunkSendsPerPlayerChoice[i] = bInt;
+            }
+        }
+    }
+
     public static final class WorldConfig {
 
         public final String worldName;
@@ -236,6 +275,11 @@ public final class TuinityConfig {
             final int threads = this.getInt("tick-threads", -1);
             this.threads = threads == -1 ? TuinityConfig.tickThreads : threads;
         }*/
+
+        public int noTickViewDistance;
+        private void noTickViewDistance() {
+            this.noTickViewDistance = this.getInt("no-tick-view-distance", -1);
+        }
     }
 
 }
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/ChunkMapDistance.java b/src/main/java/net/minecraft/server/ChunkMapDistance.java
index f92b429e8644364a667648b680f086c08bcb3d31..2ea8b9568fd082f3237f2efaaa4ce7f4c36fd8c3 100644
--- a/src/main/java/net/minecraft/server/ChunkMapDistance.java
+++ b/src/main/java/net/minecraft/server/ChunkMapDistance.java
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import com.tuinity.tuinity.util.Util; // Tuinity
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Sets;
 import com.mojang.datafixers.util.Either;
@@ -27,12 +28,12 @@ import org.apache.logging.log4j.Logger;
 public abstract class ChunkMapDistance {
 
     private static final Logger LOGGER = LogManager.getLogger();
-    private static final int b = 33 + ChunkStatus.a(ChunkStatus.FULL) - 2;
+    private static final int b = 33 + ChunkStatus.a(ChunkStatus.FULL) - 2; public static int getPlayerTicketLevel() { return ChunkMapDistance.b; } // Tuinity - OBFHELPER
     private final Long2ObjectMap<ObjectSet<EntityPlayer>> c = new Long2ObjectOpenHashMap();
     public final Long2ObjectOpenHashMap<ArraySetSorted<Ticket<?>>> tickets = new Long2ObjectOpenHashMap();
     private final ChunkMapDistance.a e = new ChunkMapDistance.a();
     private final ChunkMapDistance.b f = new ChunkMapDistance.b(8);
-    private final ChunkMapDistance.c g = new ChunkMapDistance.c(33);
+    //private final ChunkMapDistance.c g = new ChunkMapDistance.c(33); // Tuinity - no longer used
     private final java.util.Queue<PlayerChunk> pendingChunkUpdates = new java.util.LinkedList<>(); // PAIL pendingChunkUpdates // Paper - use a queue
     private final ChunkTaskQueueSorter i;
     private final Mailbox<ChunkTaskQueueSorter.a<Runnable>> j;
@@ -41,6 +42,69 @@ public abstract class ChunkMapDistance {
     private final Executor m;
     private long currentTick;
 
+    // Tuinity start
+    protected PlayerChunkMap chunkMap;
+    protected final ChunkMapDistance.TicketTracker playerTickViewDistanceHandler = new TicketTracker(ChunkMapDistance.getPlayerTicketLevel()) {
+        @Override
+        protected int tryQueueChunk(int chunkX, int chunkZ, EntityPlayer player) {
+            long coordinate = Util.getCoordinateKey(chunkX, chunkZ);
+            PlayerChunk currentChunk = ChunkMapDistance.this.chunkMap.chunkMap.getUpdating(coordinate);
+            if (currentChunk != null) {
+                Chunk fullChunk = currentChunk.getFullReadyChunk();
+                if (fullChunk != null && fullChunk.areNeighboursLoaded(2)) {
+                    this.chunkReferenceMap.putIfAbsent(coordinate, LOADED_PLAYER_REFERENCE);
+                    ChunkMapDistance.this.addTicket(coordinate, new Ticket<>(TicketType.PLAYER, this.ticketLevel, new ChunkCoordIntPair(chunkX, chunkZ)));
+                    return QUEUED;
+                }
+            }
+
+            return FAILED;
+        }
+
+        @Override
+        protected int getMaxChunkLoads(EntityPlayer player) {
+            return Integer.MAX_VALUE;
+        }
+    };
+
+    // this is copied from ChunkMapDistance.a(long, int, boolean, boolean), TODO check on update
+    // this is invoked if and only if there are no other players in range of the chunk.
+    public void playerMoveInRange(final int chunkX, final int chunkZ, final int fromX, final int fromZ) {
+        final long coordinate = Util.getCoordinateKey(chunkX, chunkZ);
+
+        final int dist = Math.max(Math.abs(chunkX - fromX), Math.abs(chunkZ - fromZ));
+        Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, 33, new ChunkCoordIntPair(chunkX, chunkZ));
+
+        ChunkMapDistance.this.j.a(ChunkTaskQueueSorter.a(() -> { // Craftbukkit - decompile error
+            ChunkMapDistance.this.m.execute(() -> {
+                if (ChunkMapDistance.this.chunkMap.playerViewDistanceNoTickMap.getObjectsInRange(coordinate) != null) {
+                    ChunkMapDistance.this.addTicket(coordinate, ticket);
+                    ChunkMapDistance.this.l.add(coordinate);
+                } else {
+                    ChunkMapDistance.this.k.a(ChunkTaskQueueSorter.a(() -> { // Craftbukkit - decompile error
+                    }, coordinate, false));
+                }
+            });
+        }, coordinate, () -> {
+            return dist;
+        }));
+    }
+
+    // this is copied from ChunkMapDistance.a(long, int, boolean, boolean), TODO check on update
+    // this is invoked if and only if there are no other players in range of the chunk.
+    public void playerMoveOutOfRange(final int chunkX, final int chunkZ, final int fromX, final int fromZ) {
+        final long coordinate = Util.getCoordinateKey(chunkX, chunkZ);
+
+        Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, 33, new ChunkCoordIntPair(chunkX, chunkZ));
+
+        ChunkMapDistance.this.k.a(ChunkTaskQueueSorter.a(() -> { // Craftbukkit - decompile error
+            ChunkMapDistance.this.m.execute(() -> {
+                ChunkMapDistance.this.removeTicket(coordinate, ticket);
+            });
+        }, coordinate, true));
+    }
+    // Tuinity end
+
     protected ChunkMapDistance(Executor executor, Executor executor1) {
         executor1.getClass();
         Mailbox<Runnable> mailbox = Mailbox.a("player ticket throttler", executor1::execute);
@@ -87,7 +151,7 @@ public abstract class ChunkMapDistance {
 
     public boolean a(PlayerChunkMap playerchunkmap) {
         this.f.a();
-        this.g.a();
+        //this.g.a(); // Tuinity - no longer used
         int i = Integer.MAX_VALUE - this.e.a(Integer.MAX_VALUE);
         boolean flag = i != 0;
 
@@ -225,7 +289,7 @@ public abstract class ChunkMapDistance {
             return new ObjectOpenHashSet();
         })).add(entityplayer);
         this.f.b(i, 0, true);
-        this.g.b(i, 0, true);
+        //this.g.b(i, 0, true); // Tuinity - no longer used
     }
 
     public void b(SectionPosition sectionposition, EntityPlayer entityplayer) {
@@ -237,7 +301,7 @@ public abstract class ChunkMapDistance {
         if (objectset.isEmpty()) {
             this.c.remove(i);
             this.f.b(i, Integer.MAX_VALUE, false);
-            this.g.b(i, Integer.MAX_VALUE, false);
+            //this.g.b(i, Integer.MAX_VALUE, false); // Tuinity - no longer used
         }
 
     }
@@ -255,9 +319,16 @@ public abstract class ChunkMapDistance {
         return s;
     }
 
+    protected void setViewDistance(int viewDistance) { this.a(viewDistance); } // Tuinity - OBFHELPER
     protected void a(int i) {
-        this.g.a(i);
+        //this.g.a(i); // Tuinity - no longer used
+    }
+    // Tuinity start - per player view distance
+    protected void setGlobalViewDistance(int viewDistance, PlayerChunkMap chunkMap) {
+        this.chunkMap = chunkMap;
+        this.setViewDistance(viewDistance);
     }
+    // Tuinity end
 
     public int b() {
         this.f.a();
@@ -339,6 +410,222 @@ public abstract class ChunkMapDistance {
         }
     }
 
+    // Tuinity start - Per player view distance
+    abstract class TicketTracker {
+
+        static final int LOADED_PLAYER_REFERENCE = -2;
+
+        protected final it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap chunkReferenceMap = new it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap(8192, 0.25f);
+        {
+            this.chunkReferenceMap.defaultReturnValue(-1);
+        }
+        protected final it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap lastLoadedRadiusByPlayer = new it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap(512, 0.5f);
+        {
+            this.lastLoadedRadiusByPlayer.defaultReturnValue(-1);
+        }
+
+        protected final it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap pendingChunkLoadsByPlayer = new it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap(512, 0.5f);
+        protected final it.unimi.dsi.fastutil.ints.Int2LongOpenHashMap lastChunkPositionByPlayer = new it.unimi.dsi.fastutil.ints.Int2LongOpenHashMap(512, 0.5f);
+        {
+            this.lastChunkPositionByPlayer.defaultReturnValue(Long.MIN_VALUE);
+        }
+
+        protected final int ticketLevel;
+
+        public TicketTracker(int ticketLevel) {
+            this.ticketLevel = ticketLevel;
+        }
+
+        protected final java.util.List<EntityPlayer> players = new java.util.ArrayList<>(256);
+
+        protected com.tuinity.tuinity.util.map.PlayerAreaMap areaMap;
+
+        static final int ALREADY_QUEUED = 0;
+        static final int QUEUED = 1;
+        static final int FAILED = 2;
+
+        protected abstract int tryQueueChunk(int chunkX, int chunkZ, EntityPlayer player);
+
+        protected abstract int getMaxChunkLoads(EntityPlayer player);
+
+        public void tick() {
+            for (EntityPlayer player : this.players) {
+                int playerId = player.getId();
+                int lastLoadedRadius = this.lastLoadedRadiusByPlayer.get(playerId);
+                int pendingChunkLoads = this.pendingChunkLoadsByPlayer.get(playerId);
+                long lastChunkPos = this.lastChunkPositionByPlayer.get(playerId);
+                long currentChunkPos = this.areaMap.getLastCoordinate(player);
+
+                if (currentChunkPos == Long.MIN_VALUE) {
+                    // not tracking for whatever reason...
+                    continue;
+                }
+
+                int newX = Util.getCoordinateX(currentChunkPos);
+                int newZ = Util.getCoordinateZ(currentChunkPos);
+
+                // handle movement
+                if (currentChunkPos != lastChunkPos) {
+                    this.lastChunkPositionByPlayer.put(playerId, currentChunkPos);
+                    if (lastChunkPos != Long.MIN_VALUE) {
+                        int oldX = Util.getCoordinateX(lastChunkPos);
+                        int oldZ = Util.getCoordinateZ(lastChunkPos);
+
+                        int radiusDiff = Math.max(Math.abs(newX - oldX), Math.abs(newZ - oldZ));
+                        lastLoadedRadius = Math.max(-1, lastLoadedRadius - radiusDiff);
+                        this.lastLoadedRadiusByPlayer.put(playerId, lastLoadedRadius);
+                    }
+                }
+
+                int maxChunkLoads = this.getMaxChunkLoads(player);
+
+                int radius = lastLoadedRadius + 1;
+                int viewDistance = this.areaMap.getLastViewDistance(player);
+
+                if (radius > viewDistance) {
+                    // distance map will unload our chunks
+                    this.lastLoadedRadiusByPlayer.put(playerId, viewDistance);
+                    continue;
+                }
+
+                if (pendingChunkLoads >= maxChunkLoads) {
+                    continue;
+                }
+
+                radius_loop:
+                for (; radius <= viewDistance; ++radius) {
+                    for (int offset = 0; offset <= radius; ++offset) {
+                        // try to load the chunks closest to the player by distance
+                        // so instead of going left->right on the x axis, we start at the center of the view distance square
+                        // and go left and right at the same time
+
+                        // try top 2 chunks
+                        // top left
+                        int attempt = 0;
+                        if ((attempt = this.tryQueueChunk(newX - offset, newZ + radius, player)) == QUEUED) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // top right
+                        if ((attempt = this.tryQueueChunk(newX + offset, newZ + radius, player)) == QUEUED) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // try bottom 2 chunks
+
+                        // bottom left
+                        if ((attempt = this.tryQueueChunk(newX - offset, newZ - radius, player)) == QUEUED) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // bottom right
+                        if ((attempt = this.tryQueueChunk(newX + offset, newZ - radius, player)) == QUEUED) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // try left 2 chunks
+
+                        // left down
+                        if ((attempt = this.tryQueueChunk(newX - radius, newZ - offset, player)) == QUEUED) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // left up
+                        if ((attempt = this.tryQueueChunk(newX - radius, newZ + offset, player)) == QUEUED) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // try right 2 chunks
+
+                        // right down
+                        if ((attempt = this.tryQueueChunk(newX + radius, newZ - offset, player)) == QUEUED) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // right up
+                        if ((attempt = this.tryQueueChunk(newX + radius, newZ + offset, player)) == QUEUED) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+                    }
+                }
+
+                int newLoadedRadius = radius - 1;
+                if (newLoadedRadius != lastLoadedRadius) {
+                    this.lastLoadedRadiusByPlayer.put(playerId, newLoadedRadius);
+                }
+                this.pendingChunkLoadsByPlayer.put(playerId, pendingChunkLoads);
+            }
+        }
+
+        public void addPlayer(EntityPlayer player) {
+            this.players.add(player);
+        }
+
+        public void removePlayer(EntityPlayer player) {
+            this.players.remove(player);
+            this.lastLoadedRadiusByPlayer.remove(player.getId());
+            this.pendingChunkLoadsByPlayer.remove(player.getId());
+            this.lastChunkPositionByPlayer.remove(player.getId());
+        }
+
+        public void onChunkLoad(int chunkX, int chunkZ) {
+            long coordinate = Util.getCoordinateKey(chunkX, chunkZ);
+            int playerReference = this.chunkReferenceMap.replace(coordinate, LOADED_PLAYER_REFERENCE);
+            if (playerReference != -1) {
+                this.pendingChunkLoadsByPlayer.computeIfPresent(playerReference, (Integer keyInMap, Integer valueInMap) -> {
+                    return valueInMap - 1;
+                });
+            }
+        }
+
+        // this is invoked if and only if there are no other players in range of the chunk.
+        public void playerMoveOutOfRange(int chunkX, int chunkZ) {
+            long coordinate = Util.getCoordinateKey(chunkX, chunkZ);
+            int playerReference = this.chunkReferenceMap.remove(coordinate);
+            if (playerReference != -1) {
+                if (playerReference != LOADED_PLAYER_REFERENCE) {
+                    this.pendingChunkLoadsByPlayer.computeIfPresent(playerReference, (Integer keyInMap, Integer valueInMap) -> {
+                        return valueInMap - 1;
+                    });
+                }
+                ChunkMapDistance.this.removeTicket(coordinate, new Ticket<>(TicketType.PLAYER, this.ticketLevel, new ChunkCoordIntPair(chunkX, chunkZ)));
+            }
+        }
+    }
+    // Tuinity end - per player view distance
+
     class c extends ChunkMapDistance.b {
 
         private int e = 0;
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 1cb9e9f291ec936a94dc0ad71330cb1ccda9260e..560399b84eb674578e71468893f09984f96710f4 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -604,6 +604,10 @@ public class ChunkProviderServer extends IChunkProvider {
         this.chunkMapDistance.purgeTickets();
         this.tickDistanceManager();
         this.world.timings.doChunkMap.stopTiming(); // Spigot
+        // Tuinity start
+        this.playerChunkMap.getChunkMapDistanceManager().playerTickViewDistanceHandler.tick();
+        this.playerChunkMap.chunkSendThrottler.tick();
+        // Tuinity end
         this.world.getMethodProfiler().exitEnter("chunks");
         this.world.timings.chunks.startTiming(); // Paper - timings
         this.tickChunks();
diff --git a/src/main/java/net/minecraft/server/EntityEnderDragon.java b/src/main/java/net/minecraft/server/EntityEnderDragon.java
index af10fc36e0a91c07f037da4b4081fe081fab82ae..bf14d33c0dda2861fdb2cbab19358b66495d16e9 100644
--- a/src/main/java/net/minecraft/server/EntityEnderDragon.java
+++ b/src/main/java/net/minecraft/server/EntityEnderDragon.java
@@ -579,9 +579,9 @@ public class EntityEnderDragon extends EntityInsentient implements IMonster {
                 // CraftBukkit start - Use relative location for far away sounds
                 // this.world.b(1028, new BlockPosition(this), 0);
                 // Paper start
-                int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
+                //int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API // Tuinity - per player view distance
                 for (EntityPlayer player : ((WorldServer)world).getPlayers()) {
-                    //final int viewDistance = player.getViewDistance(); // TODO apply view distance api patch
+                    final int viewDistance = player.getEffectiveViewDistance(player.getWorldServer().getChunkProvider().playerChunkMap) << 4; // Tuinity - per player view distance
                     // Paper end
                     double deltaX = this.locX() - player.locX();
                     double deltaZ = this.locZ() - player.locZ();
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index 0e1bd031f7f6a65381b2e3f1e136e608608348a2..51494ee15ae6923014d2d6f954d9c4887a9402b5 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -113,6 +113,33 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public final com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> cachedSingleHashSetTuinity;
     // Tuinity end
 
+    // Tuinity start - view distance api
+    final it.unimi.dsi.fastutil.longs.LongOpenHashSet loadedChunks = new it.unimi.dsi.fastutil.longs.LongOpenHashSet();
+
+    boolean needsChunkCenterUpdate;
+    int viewDistance = -1;
+    public final int getRawViewDistance() {
+        return this.viewDistance;
+    }
+    public final int getEffectiveViewDistance() {
+        return this.getEffectiveViewDistance(((WorldServer)this.world).getChunkProvider().playerChunkMap);
+    }
+    public final int getEffectiveViewDistance(PlayerChunkMap chunkMap) {
+        return this.viewDistance == -1 ? chunkMap.viewDistance : this.viewDistance;
+    }
+
+    int noTickViewDistance = -1;
+    public final int getRawNoTickViewDistance() {
+        return this.noTickViewDistance;
+    }
+    public final int getEffectiveNoTickViewDistance() {
+        return this.getEffectiveNoTickViewDistance(((WorldServer)this.world).getChunkProvider().playerChunkMap);
+    }
+    public final int getEffectiveNoTickViewDistance(PlayerChunkMap chunkMap) {
+        return this.noTickViewDistance == -1 ? chunkMap.noTickViewDistance : this.noTickViewDistance;
+    }
+    // Tuinity end - view distance api
+
     public EntityPlayer(MinecraftServer minecraftserver, WorldServer worldserver, GameProfile gameprofile, PlayerInteractManager playerinteractmanager) {
         super((World) worldserver, gameprofile);
         playerinteractmanager.player = this;
diff --git a/src/main/java/net/minecraft/server/EntityWither.java b/src/main/java/net/minecraft/server/EntityWither.java
index 8977c3516b2ee9b970b6274a5c71982b019ac2a6..bace6cf36a9e888278a6c7a5c5866d9f3b9ecf87 100644
--- a/src/main/java/net/minecraft/server/EntityWither.java
+++ b/src/main/java/net/minecraft/server/EntityWither.java
@@ -208,9 +208,9 @@ public class EntityWither extends EntityMonster implements IRangedEntity {
                 // CraftBukkit start - Use relative location for far away sounds
                 // this.world.b(1023, new BlockPosition(this), 0);
                 // Paper start
-                int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
+                //int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API // Tuinity - per player view distance
                 for (EntityPlayer player : ((WorldServer)world).getPlayers()) {
-                    //final int viewDistance = player.getViewDistance(); // TODO apply view distance api patch
+                    final int viewDistance = player.getEffectiveViewDistance(player.getWorldServer().getChunkProvider().playerChunkMap) << 4; // Tuinity - per player view distance
                     // Paper end
                     double deltaX = this.locX() - player.locX();
                     double deltaZ = this.locZ() - player.locZ();
diff --git a/src/main/java/net/minecraft/server/PlayerChunk.java b/src/main/java/net/minecraft/server/PlayerChunk.java
index f9100a27177d4cd23ce7f96b3329c9ad6ff8937f..d822e6c86c75c618deccdce982ace58eaf4fcf13 100644
--- a/src/main/java/net/minecraft/server/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/PlayerChunk.java
@@ -194,7 +194,7 @@ public class PlayerChunk {
     }
 
     public void a(int i, int j, int k) {
-        Chunk chunk = this.getChunk();
+        Chunk chunk = this.getFullReadyChunk(); // Tuinity - per player view distance - allow block updates in non-ticking chunks
 
         if (chunk != null) {
             this.r |= 1 << (j >> 4);
@@ -214,7 +214,7 @@ public class PlayerChunk {
     }
 
     public void a(EnumSkyBlock enumskyblock, int i) {
-        Chunk chunk = this.getChunk();
+        Chunk chunk = this.getFullReadyChunk(); // Tuinity - per player view distance - allow block updates in non-ticking chunks
 
         if (chunk != null) {
             chunk.setNeedsSaving(true);
@@ -304,9 +304,57 @@ public class PlayerChunk {
     }
 
     private void a(Packet<?> packet, boolean flag) {
-        this.players.a(this.location, flag).forEach((entityplayer) -> {
-            entityplayer.playerConnection.sendPacket(packet);
-        });
+        // Tuinity start - per player view distance
+        // there can be potential desync with player's last mapped section and the view distance map, so use the
+        // view distance map here.
+        PlayerChunkMap chunkMap = ((PlayerChunkMap)this.players);
+        com.tuinity.tuinity.util.map.PlayerAreaMap viewDistanceMap = chunkMap.playerViewDistanceBroadcastMap;
+        com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> players = viewDistanceMap.getObjectsInRange(this.location);
+        if (players == null) {
+            return;
+        }
+
+        long coordinate = com.tuinity.tuinity.util.Util.getCoordinateKey(this.location);
+
+        if (flag) { // flag -> border only
+            Object[] backingSet = players.getBackingSet();
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof EntityPlayer)) {
+                    continue;
+                }
+                EntityPlayer player = (EntityPlayer)temp;
+                if (!player.loadedChunks.contains(coordinate)) {
+                    continue;
+                }
+
+                int viewDistance = viewDistanceMap.getLastViewDistance(player);
+                long lastPosition = viewDistanceMap.getLastCoordinate(player);
+
+                int distX = Math.abs(com.tuinity.tuinity.util.Util.getCoordinateX(lastPosition) - this.location.x);
+                int distZ = Math.abs(com.tuinity.tuinity.util.Util.getCoordinateZ(lastPosition) - this.location.z);
+
+                if (Math.max(distX, distZ) == viewDistance) {
+                    player.playerConnection.sendPacket(packet);
+                }
+            }
+        } else {
+            Object[] backingSet = players.getBackingSet();
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof EntityPlayer)) {
+                    continue;
+                }
+                EntityPlayer player = (EntityPlayer)temp;
+                if (!player.loadedChunks.contains(coordinate)) {
+                    continue;
+                }
+                player.playerConnection.sendPacket(packet);
+            }
+        }
+
+        return;
+        // Tuinity end - per player view distance
     }
 
     public CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> a(ChunkStatus chunkstatus, PlayerChunkMap playerchunkmap) {
@@ -515,6 +563,9 @@ public class PlayerChunk {
                     // Tuinity end - stop throwing garbage on the heap
 
 
+                    // Tuinity start - per player view distance implementation
+                    PlayerChunk.this.chunkMap.getChunkMapDistanceManager().playerTickViewDistanceHandler.onChunkLoad(this.location.x, this.location.z);
+                    // Tuinity end - per player view distance implementation
                 }
             });
             // Paper end
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index ec13a1c157bdb2561ee6f1ff7d86f816cda0e953..bfe33710c1d54d80d989b0d838e2dd32b070159c 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -79,7 +79,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     private final PlayerMap playerMap;
     public final Int2ObjectMap<PlayerChunkMap.EntityTracker> trackedEntities;
     private final Queue<Runnable> z;
-    int viewDistance; // Paper - private -> package private
+    int viewDistance; public final int getViewDistance() { return this.viewDistance; } // Tuinity - OBFHELPER // Paper - private -> package private
     //public final com.destroystokyo.paper.util.PlayerMobDistanceMap playerMobDistanceMap; // Paper // Tuinity - replaced by view distance map
 
     // CraftBukkit start - recursion-safe executor for Chunk loadCallback() and unloadCallback()
@@ -110,6 +110,244 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     // Paper start - distance maps
     private final com.destroystokyo.paper.util.misc.PooledLinkedHashSets<EntityPlayer> pooledLinkedPlayerHashSets = new com.destroystokyo.paper.util.misc.PooledLinkedHashSets<>();
 
+    // Tuinity start - per player view distance
+    int noTickViewDistance;
+    public final int getNoTickViewDistance() {
+        return this.noTickViewDistance;
+    }
+    // we use this map to broadcast chunks to clients
+    // they do not render chunks without having at least neighbours in a 1 chunk radius loaded
+    public final com.tuinity.tuinity.util.map.PlayerAreaMap playerViewDistanceBroadcastMap;
+    public final com.tuinity.tuinity.util.map.PlayerAreaMap playerViewDistanceTickMap;
+    public final com.tuinity.tuinity.util.map.PlayerAreaMap playerViewDistanceNoTickMap;
+
+    final ChunkSendThrottler chunkSendThrottler = new ChunkSendThrottler();
+
+    public void updateViewDistance(EntityPlayer player, int viewDistance, int noTickViewDistance) {
+        player.viewDistance = viewDistance;
+        player.noTickViewDistance = noTickViewDistance;
+
+        int chunkX = com.tuinity.tuinity.util.Util.getChunkCoordinate(player.locX());
+        int chunkZ = com.tuinity.tuinity.util.Util.getChunkCoordinate(player.locZ());
+
+        int effectiveViewDistance = viewDistance == -1 ? this.viewDistance : viewDistance;
+        int effectiveNoTickViewDistance = Math.max(effectiveViewDistance, noTickViewDistance == -1 ? this.noTickViewDistance : noTickViewDistance);
+
+        player.playerConnection.sendPacket(new PacketPlayOutViewDistance(effectiveNoTickViewDistance));
+
+        if (!this.cannotLoadChunks(player)) {
+            this.playerViewDistanceTickMap.update(player, chunkX, chunkZ, effectiveViewDistance);
+            this.playerViewDistanceNoTickMap.update(player, chunkX, chunkZ, effectiveNoTickViewDistance + 2); // clients need chunk neighbours // add an extra one for antixray
+        }
+        this.playerViewDistanceMap.update(player, chunkX, chunkZ, effectiveViewDistance);
+        player.needsChunkCenterUpdate = true;
+        this.playerViewDistanceBroadcastMap.update(player, chunkX, chunkZ, effectiveNoTickViewDistance + 1); // clients need chunk neighbours
+        player.needsChunkCenterUpdate = false;
+    }
+
+    final class ChunkSendThrottler {
+
+        static final int ALREADY_QUEUED = 0;
+        static final int QUEUED = 1;
+        static final int FAILED = 2;
+
+        protected final it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap lastLoadedRadiusByPlayer = new it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap(512, 0.5f);
+
+        {
+            this.lastLoadedRadiusByPlayer.defaultReturnValue(-1);
+        }
+
+        protected final it.unimi.dsi.fastutil.ints.Int2LongOpenHashMap lastChunkPositionByPlayer = new it.unimi.dsi.fastutil.ints.Int2LongOpenHashMap(512, 0.5f);
+
+        {
+            this.lastChunkPositionByPlayer.defaultReturnValue(Long.MIN_VALUE);
+        }
+
+        protected final it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap chunkSendCountPerPlayer = new it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap(512, 0.5f);
+
+        protected final it.unimi.dsi.fastutil.ints.Int2LongOpenHashMap lastChunkSendStartTimePerPlayer = new it.unimi.dsi.fastutil.ints.Int2LongOpenHashMap(512, 0.5f);
+
+        protected final java.util.List<EntityPlayer> players = new java.util.ArrayList<>(256);
+
+        protected final it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<Packet[]> cachedChunkPackets = new it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<>();
+
+        void addPlayer(EntityPlayer player) {
+            this.players.add(player);
+        }
+
+        void removePlayer(EntityPlayer player) {
+            this.players.remove(player);
+            this.lastLoadedRadiusByPlayer.remove(player.getId());
+            this.chunkSendCountPerPlayer.remove(player.getId());
+            this.lastChunkPositionByPlayer.remove(player.getId());
+            player.loadedChunks.clear();
+        }
+
+        int trySendChunk(int chunkX, int chunkZ, EntityPlayer player) {
+            long coordinate = com.tuinity.tuinity.util.Util.getCoordinateKey(chunkX, chunkZ);
+            PlayerChunk playerChunk = PlayerChunkMap.this.chunkMap.getUpdating(coordinate);
+
+            if (playerChunk == null) {
+                return FAILED;
+            }
+            Chunk chunk = playerChunk.getFullReadyChunk();
+            if (chunk == null || !chunk.areNeighboursLoaded(1)) {
+                return FAILED;
+            }
+
+            if (!player.loadedChunks.add(coordinate)) {
+                return ALREADY_QUEUED;
+            }
+
+            Packet[] chunkPackets = this.cachedChunkPackets.computeIfAbsent(coordinate, (long keyInMap) -> new Packet[2]);
+            PlayerChunkMap.this.sendChunk(player, chunkPackets, chunk);
+
+            return QUEUED;
+        }
+
+        void tick() {
+            int maxChunkSends = com.tuinity.tuinity.config.TuinityConfig.maxChunkSendsPerPlayerChoice[MinecraftServer.currentTick % com.tuinity.tuinity.config.TuinityConfig.maxChunkSendsPerPlayerChoice.length];
+            for (EntityPlayer player : this.players) {
+                int playerId = player.getId();
+                int lastLoadedRadius = this.lastLoadedRadiusByPlayer.get(playerId);
+                long lastChunkPos = this.lastChunkPositionByPlayer.get(playerId);
+                long currentChunkPos = PlayerChunkMap.this.playerViewDistanceBroadcastMap.getLastCoordinate(player);
+
+                if (currentChunkPos == Long.MIN_VALUE) {
+                    // not tracking for whatever reason...
+                    continue;
+                }
+
+                int newX = com.tuinity.tuinity.util.Util.getCoordinateX(currentChunkPos);
+                int newZ = com.tuinity.tuinity.util.Util.getCoordinateZ(currentChunkPos);
+
+                // handle movement
+                if (currentChunkPos != lastChunkPos) {
+                    this.lastChunkPositionByPlayer.put(playerId, currentChunkPos);
+                    if (lastChunkPos != Long.MIN_VALUE) {
+                        int oldX = com.tuinity.tuinity.util.Util.getCoordinateX(lastChunkPos);
+                        int oldZ = com.tuinity.tuinity.util.Util.getCoordinateZ(lastChunkPos);
+
+                        int radiusDiff = Math.max(Math.abs(newX - oldX), Math.abs(newZ - oldZ));
+                        lastLoadedRadius = Math.max(-1, lastLoadedRadius - radiusDiff);
+                        this.lastLoadedRadiusByPlayer.put(playerId, lastLoadedRadius);
+                    }
+                }
+
+                int radius = lastLoadedRadius + 1;
+                int viewDistance = PlayerChunkMap.this.playerViewDistanceBroadcastMap.getLastViewDistance(player);
+
+                if (radius > viewDistance) {
+                    // distance map will unload our chunks
+                    this.lastLoadedRadiusByPlayer.put(playerId, viewDistance);
+                    continue;
+                }
+
+                int totalChunkSends = 0;
+
+                if (totalChunkSends >= maxChunkSends) {
+                    continue;
+                }
+
+                radius_loop:
+                for (; radius <= viewDistance; ++radius) {
+                    for (int offset = 0; offset <= radius; ++offset) {
+                        // try to load the chunks closest to the player by distance
+                        // so instead of going left->right on the x axis, we start at the center of the view distance square
+                        // and go left and right at the same time
+
+                        // try top 2 chunks
+                        // top left
+                        int attempt = 0;
+                        if ((attempt = this.trySendChunk(newX - offset, newZ + radius, player)) == QUEUED) {
+                            if (++totalChunkSends >= maxChunkSends) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // top right
+                        if ((attempt = this.trySendChunk(newX + offset, newZ + radius, player)) == QUEUED) {
+                            if (++totalChunkSends >= maxChunkSends) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // try bottom 2 chunks
+
+                        // bottom left
+                        if ((attempt = this.trySendChunk(newX - offset, newZ - radius, player)) == QUEUED) {
+                            if (++totalChunkSends >= maxChunkSends) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // bottom right
+                        if ((attempt = this.trySendChunk(newX + offset, newZ - radius, player)) == QUEUED) {
+                            if (++totalChunkSends >= maxChunkSends) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // try left 2 chunks
+
+                        // left down
+                        if ((attempt = this.trySendChunk(newX - radius, newZ - offset, player)) == QUEUED) {
+                            if (++totalChunkSends >= maxChunkSends) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // left up
+                        if ((attempt = this.trySendChunk(newX - radius, newZ + offset, player)) == QUEUED) {
+                            if (++totalChunkSends >= maxChunkSends) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // try right 2 chunks
+
+                        // right down
+                        if ((attempt = this.trySendChunk(newX + radius, newZ - offset, player)) == QUEUED) {
+                            if (++totalChunkSends >= maxChunkSends) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // right up
+                        if ((attempt = this.trySendChunk(newX + radius, newZ + offset, player)) == QUEUED) {
+                            if (++totalChunkSends >= maxChunkSends) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+                    }
+                }
+                int newLoadedRadius = radius - 1;
+                if (newLoadedRadius != lastLoadedRadius) {
+                    this.lastLoadedRadiusByPlayer.put(playerId, newLoadedRadius);
+                }
+            }
+            this.cachedChunkPackets.clear();
+        }
+    }
+
+    // Tuinity end - per player view distance
+
     void addPlayerToDistanceMaps(EntityPlayer player) {
         this.updateMaps(player);
 
@@ -141,10 +379,22 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     void addPlayerToDistanceMapsTuinity(EntityPlayer player) {
         this.updateMapsTuinity(player);
+
+        // Tuinity start - per player view distance
+        this.getChunkMapDistanceManager().playerTickViewDistanceHandler.addPlayer(player);
+        this.chunkSendThrottler.addPlayer(player);
+        // Tuinity end - per player view distance
     }
 
     void removePlayerFromDistanceMapsTuinity(EntityPlayer player) {
         this.playerViewDistanceMap.remove(player);
+        // Tuinity start - per player view distance
+        this.playerViewDistanceBroadcastMap.remove(player);
+        this.playerViewDistanceTickMap.remove(player);
+        this.playerViewDistanceNoTickMap.remove(player);
+        this.getChunkMapDistanceManager().playerTickViewDistanceHandler.removePlayer(player);
+        this.chunkSendThrottler.removePlayer(player);
+        // Tuinity end - per player view distance
     }
 
     void updateDistanceMapsTuinity(EntityPlayer player) {
@@ -155,7 +405,20 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         int chunkX = com.tuinity.tuinity.util.Util.getChunkCoordinate(player.locX());
         int chunkZ = com.tuinity.tuinity.util.Util.getChunkCoordinate(player.locZ());
 
-        this.playerViewDistanceMap.update(player, chunkX, chunkZ, this.viewDistance);
+        this.playerViewDistanceMap.update(player, chunkX, chunkZ, player.getEffectiveViewDistance(this)); // Tuinity - per player view distance
+
+        // Tuinity start - per player view distance
+        int effectiveViewDistance = player.getEffectiveViewDistance(this);
+        int effectiveNoTickViewDistance = Math.max(effectiveViewDistance, player.getEffectiveNoTickViewDistance(this));
+
+        if (!this.cannotLoadChunks(player)) {
+            this.playerViewDistanceTickMap.update(player, chunkX, chunkZ, effectiveViewDistance);
+            this.playerViewDistanceNoTickMap.update(player, chunkX, chunkZ, effectiveNoTickViewDistance + 2); // clients need chunk neighbours // add an extra one for antixray
+        }
+        player.needsChunkCenterUpdate = true;
+        this.playerViewDistanceBroadcastMap.update(player, chunkX, chunkZ, effectiveNoTickViewDistance + 1); // clients need chunk neighbours
+        player.needsChunkCenterUpdate = false;
+        // Tuinity end - per player view distance
     }
     // Tuinity end
 
@@ -229,6 +492,47 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         com.tuinity.tuinity.util.map.PooledLinkedHashSets<EntityPlayer> sets = this.pooledEntityPlayerSets;
         this.playerViewDistanceMap = new com.tuinity.tuinity.util.map.PlayerAreaMap(sets);
         // Tuinity end - distance maps
+        // Tuinity start - per player view distance
+        this.setNoTickViewDistance(this.world.tuinityConfig.noTickViewDistance < 0 ? this.viewDistance : this.world.tuinityConfig.noTickViewDistance);
+        this.playerViewDistanceTickMap = new com.tuinity.tuinity.util.map.PlayerAreaMap(sets,
+                null,
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    if (newState != null) {
+                        return;
+                    }
+                    PlayerChunkMap.this.chunkDistanceManager.playerTickViewDistanceHandler.playerMoveOutOfRange(rangeX, rangeZ);
+                });
+        this.chunkDistanceManager.playerTickViewDistanceHandler.areaMap = this.playerViewDistanceTickMap;
+        this.playerViewDistanceNoTickMap = new com.tuinity.tuinity.util.map.PlayerAreaMap(sets,
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    if (newState.size() != 1) {
+                        return;
+                    }
+                    PlayerChunkMap.this.chunkDistanceManager.playerMoveInRange(rangeX, rangeZ, currPosX, currPosZ);
+                },
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    if (newState != null) {
+                        return;
+                    }
+                    PlayerChunkMap.this.chunkDistanceManager.playerMoveOutOfRange(rangeX, rangeZ, currPosX, currPosZ);
+                });
+        this.playerViewDistanceBroadcastMap = new com.tuinity.tuinity.util.map.PlayerAreaMap(sets,
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    if (player.needsChunkCenterUpdate) {
+                        player.needsChunkCenterUpdate = false;
+                        player.playerConnection.sendPacket(new PacketPlayOutViewCentre(currPosX, currPosZ));
+                    }
+                },
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    PlayerChunkMap.this.sendChunk(player, rangeX, rangeZ, null, true, false); // unloaded, loaded
+                    player.loadedChunks.remove(com.tuinity.tuinity.util.Util.getCoordinateKey(rangeX, rangeZ));
+                });
+        // Tuinity end - per player view distance
     }
 
     public void updatePlayerMobTypeMap(Entity entity) {
@@ -990,11 +1294,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         completablefuture1.thenAcceptAsync((either) -> {
             either.mapLeft((chunk) -> {
                 this.u.getAndIncrement();
-                Packet<?>[] apacket = new Packet[2];
-
-                this.a(chunkcoordintpair, false).forEach((entityplayer) -> {
-                    this.a(entityplayer, apacket, chunk);
-                });
+                // Tuinity - per player view distance - moved to full chunk load, instead of ticking load
                 return Either.left(chunk);
             });
         }, (runnable) -> {
@@ -1098,32 +1398,39 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         } // Paper
     }
 
-    protected void setViewDistance(int i) {
-        int j = MathHelper.clamp(i + 1, 3, 33);
+    public void setViewDistance(int i) { // Tuinity - make public
+        int j = MathHelper.clamp(i + 1, 3, 33) - 1; // Tuinity - we correctly handle view distance, no need to add 1
 
         if (j != this.viewDistance) {
             int k = this.viewDistance;
 
             this.viewDistance = j;
-            this.chunkDistanceManager.a(this.viewDistance);
-            Iterator objectiterator = this.chunkMap.getUpdatingValues().iterator(); // Tuinity - replace chunk map
-
-            while (objectiterator.hasNext()) {
-                PlayerChunk playerchunk = (PlayerChunk) objectiterator.next();
-                ChunkCoordIntPair chunkcoordintpair = playerchunk.i();
-                Packet<?>[] apacket = new Packet[2];
+            this.chunkDistanceManager.setGlobalViewDistance(this.viewDistance, this); // Tuinity - per player view distance
+            // Tuinity start - view distance map handles this
+            if (this.world != null && this.world.players != null) { // ... called inside constructor, where these may not be initialized
+                for (EntityPlayer player : this.world.players) {
+                    this.updateViewDistance(player, player.getRawViewDistance(), player.getRawNoTickViewDistance());
+                }
+            }
+            // Tuinity end - view distance map handles this
+        }
 
-                this.a(chunkcoordintpair, false).forEach((entityplayer) -> {
-                    int l = b(chunkcoordintpair, entityplayer, true);
-                    boolean flag = l <= k;
-                    boolean flag1 = l <= this.viewDistance;
+    }
 
-                    this.sendChunk(entityplayer, chunkcoordintpair, apacket, flag, flag1);
-                });
+    // Tuinity start - no ticket view distance
+    public void setNoTickViewDistance(int noTickViewDistance) {
+        // modeled after the above
+        noTickViewDistance = MathHelper.clamp(noTickViewDistance, 2, 32);
+        if (this.noTickViewDistance != noTickViewDistance) {
+            this.noTickViewDistance = noTickViewDistance;
+            if (this.world != null && this.world.players != null) { // ... called inside constructor, where these may not be initialized
+                for (EntityPlayer player : this.world.players) {
+                    this.updateViewDistance(player, player.getRawViewDistance(), player.getRawNoTickViewDistance());
+                }
             }
         }
-
     }
+    // Tuinity end
 
     protected void sendChunk(EntityPlayer entityplayer, ChunkCoordIntPair chunkcoordintpair, Packet<?>[] apacket, boolean flag, boolean flag1) {
         // Tuinity start - remove ChunkCoordIntPair allocation, use two ints instead of ChunkCoordIntPair
@@ -1136,7 +1443,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 PlayerChunk playerchunk = this.getVisibleChunk(ChunkCoordIntPair.pair(chunkX, chunkZ)); // Tuinity - remove ChunkCoordIntPair allocation
 
                 if (playerchunk != null) {
-                    Chunk chunk = playerchunk.getChunk();
+                    Chunk chunk = playerchunk.getFullReadyChunk(); // Tuinity - per player view distance
 
                     if (chunk != null) {
                         this.a(entityplayer, apacket, chunk);
@@ -1382,6 +1689,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         });
     }
 
+    private boolean cannotLoadChunks(EntityPlayer entityplayer) { return this.b(entityplayer); } // Tuinity - OBFHELPER
     private boolean b(EntityPlayer entityplayer) {
         return entityplayer.isSpectator() && !this.world.getGameRules().getBoolean(GameRules.SPECTATORS_GENERATE_CHUNKS);
     }
@@ -1407,15 +1715,11 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             }
         }
 
-        Packet[] cachedPackets = new Packet[2]; // Tuinity
-        for (int k = i - this.viewDistance; k <= i + this.viewDistance; ++k) {
-            for (int l = j - this.viewDistance; l <= j + this.viewDistance; ++l) {
-                // Tuinity start - remove excess object creation (ChunkCoordIntPair and Packet[])
-                this.sendChunk(entityplayer, k, l, cachedPackets, !flag, flag);
-                java.util.Arrays.fill(cachedPackets, null);
-                // Tuinity end
-            }
+        // Tuinity start - view distance map handles this
+        if (flag) {
+            this.updateMaps(entityplayer);
         }
+        // Tuinity end - view distance map handles this
 
     }
 
@@ -1423,7 +1727,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         SectionPosition sectionposition = SectionPosition.a((Entity) entityplayer);
 
         entityplayer.a(sectionposition);
-        entityplayer.playerConnection.sendPacket(new PacketPlayOutViewCentre(sectionposition.a(), sectionposition.c()));
+        //entityplayer.playerConnection.sendPacket(new PacketPlayOutViewCentre(sectionposition.a(), sectionposition.c())); // Tuinity - distance map handles this now
         return sectionposition;
     }
 
@@ -1490,68 +1794,53 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         int k1;
         int l1;
 
-        if (Math.abs(i1 - i) <= this.viewDistance * 2 && Math.abs(j1 - j) <= this.viewDistance * 2) {
-            k1 = Math.min(i, i1) - this.viewDistance;
-            l1 = Math.min(j, j1) - this.viewDistance;
-            int i2 = Math.max(i, i1) + this.viewDistance;
-            int j2 = Math.max(j, j1) + this.viewDistance;
+        this.updateMaps(entityplayer); // Paper - distance maps
+        this.updateDistanceMapsTuinity(entityplayer); // Tuinity - distance maps
+    }
 
-            Packet[] cachedPackets = new Packet[2]; // Tuinity
+    @Override
+    public Stream<EntityPlayer> a(ChunkCoordIntPair chunkcoordintpair, boolean flag) {
+        // Tuinity start - per player view distance
+        // there can be potential desync with player's last mapped section and the view distance map, so use the
+        // view distance map here.
+        com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> inRange = this.playerViewDistanceBroadcastMap.getObjectsInRange(chunkcoordintpair);
+
+        if (inRange == null) {
+            return Stream.empty();
+        }
+        // all current cases are inlined so we wont hit this code, it's just in case plugins or future updates use it
+        List<EntityPlayer> players = new ArrayList<>();
+        Object[] backingSet = inRange.getBackingSet();
+
+        if (flag) { // flag -> border only
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof EntityPlayer)) {
+                    continue;
+                }
+                EntityPlayer player = (EntityPlayer)temp;
+                int viewDistance = this.playerViewDistanceBroadcastMap.getLastViewDistance(player);
+                long lastPosition = this.playerViewDistanceBroadcastMap.getLastCoordinate(player);
 
-            for (int k2 = k1; k2 <= i2; ++k2) {
-                for (int l2 = l1; l2 <= j2; ++l2) {
-                    // Tuinity start - remove ChunkCoordIntPair allocation
-                    boolean flag3 = getSquareRadiusDistance(k2, l2, i1, j1) <= this.viewDistance;
-                    boolean flag4 = getSquareRadiusDistance(k2, l2, i, j) <= this.viewDistance;
+                int distX = Math.abs(com.tuinity.tuinity.util.Util.getCoordinateX(lastPosition) - chunkcoordintpair.x);
+                int distZ = Math.abs(com.tuinity.tuinity.util.Util.getCoordinateZ(lastPosition) - chunkcoordintpair.z);
 
-                    this.sendChunk(entityplayer, k2, l2, cachedPackets, flag3, flag4);
-                    java.util.Arrays.fill(cachedPackets, null);
-                    // Tuinity end
+                if (Math.max(distX, distZ) == viewDistance) {
+                    players.add(player);
                 }
             }
         } else {
-            //ChunkCoordIntPair chunkcoordintpair1; // Tuinity - we don't set, so compile fail on further uses
-            boolean flag5;
-            boolean flag6;
-
-            Packet[] cachedPackets = new Packet[2]; // Tuinity
-
-            for (k1 = i1 - this.viewDistance; k1 <= i1 + this.viewDistance; ++k1) {
-                for (l1 = j1 - this.viewDistance; l1 <= j1 + this.viewDistance; ++l1) {
-                    // Tuinity - remove ChunkCoordIntPair allocation
-                    flag5 = true;
-                    flag6 = false;
-                    // Tuinity start - remove ChunkCoordIntPair allocation
-                    this.sendChunk(entityplayer, k1, l1, cachedPackets, true, false);
-                    java.util.Arrays.fill(cachedPackets, null);
-                    // Tuinity end
-                }
-            }
-
-            for (k1 = i - this.viewDistance; k1 <= i + this.viewDistance; ++k1) {
-                for (l1 = j - this.viewDistance; l1 <= j + this.viewDistance; ++l1) {
-                    // Tuinity - remove ChunkCoordIntPair allocation
-                    flag5 = false;
-                    flag6 = true;
-                    // Tuinity start - remove ChunkCoordIntPair allocation
-                    this.sendChunk(entityplayer, k1, l1, cachedPackets, false, true);
-                    java.util.Arrays.fill(cachedPackets, null);
-                    // Tuinity end
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof EntityPlayer)) {
+                    continue;
                 }
+                EntityPlayer player = (EntityPlayer)temp;
+                players.add(player);
             }
         }
 
-        this.updateMaps(entityplayer); // Paper - distance maps
-        this.updateDistanceMapsTuinity(entityplayer); // Tuinity - distance maps
-    }
-
-    @Override
-    public Stream<EntityPlayer> a(ChunkCoordIntPair chunkcoordintpair, boolean flag) {
-        return this.playerMap.a(chunkcoordintpair.pair()).filter((entityplayer) -> {
-            int i = b(chunkcoordintpair, entityplayer, true);
-
-            return i > this.viewDistance ? false : !flag || i == this.viewDistance;
-        });
+        return players.stream();
     }
 
     protected void addEntity(Entity entity) {
@@ -1689,6 +1978,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     }
 
+    final void sendChunk(EntityPlayer entityplayer, Packet<?>[] apacket, Chunk chunk) { this.a(entityplayer, apacket, chunk); } // Tuinity - OBFHELPER
     private void a(EntityPlayer entityplayer, Packet<?>[] apacket, Chunk chunk) {
         if (apacket[0] == null) {
             apacket[0] = new PacketPlayOutMapChunk(chunk, 65535, true); // Paper - Anti-Xray
@@ -1826,7 +2116,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 double vec3d_dy = entityplayer.locY() - this.tracker.locY();
                 double vec3d_dz = entityplayer.locZ() - this.tracker.locZ();
                 // Tuinity end - remove allocation of Vec3d here
-                int i = Math.min(this.b(), (PlayerChunkMap.this.viewDistance - 1) * 16);
+                int i = Math.min(this.b(), (entityplayer.getEffectiveViewDistance(PlayerChunkMap.this)) * 16);  // Tuinity - per player view distance
                 boolean flag = vec3d_dx >= (double) (-i) && vec3d_dx <= (double) i && vec3d_dz >= (double) (-i) && vec3d_dz <= (double) i && this.tracker.a(entityplayer); // Tuinity start - remove allocation of Vec3d here
                 if (flag) {
                     boolean flag1 = this.tracker.attachedToPlayer;
@@ -1836,7 +2126,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                         PlayerChunk playerchunk = PlayerChunkMap.this.getVisibleChunk(chunkcoordintpair.pair());
 
                         if (playerchunk != null && playerchunk.getChunk() != null) {
-                            flag1 = PlayerChunkMap.b(chunkcoordintpair, entityplayer, false) <= PlayerChunkMap.this.viewDistance;
+                            flag1 = PlayerChunkMap.b(chunkcoordintpair, entityplayer, false) <= (1 + PlayerChunkMap.this.playerViewDistanceTickMap.getLastViewDistance(entityplayer)) && entityplayer.loadedChunks.contains(com.tuinity.tuinity.util.Util.getCoordinateKey(this.tracker)); // Tuinity - per player view distance
                         }
                     }
 
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index 7b79ee4fe5893d0c8c5825776c3c09ca8553abc8..253ee52eb51cfc95a671cad6e188bc07d4a000c1 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -156,7 +156,7 @@ public abstract class PlayerList {
 
         // CraftBukkit - getType()
         // Spigot - view distance
-        playerconnection.sendPacket(new PacketPlayOutLogin(entityplayer.getId(), entityplayer.playerInteractManager.getGameMode(), WorldData.c(worlddata.getSeed()), worlddata.isHardcore(), worldserver.worldProvider.getDimensionManager().getType(), this.getMaxPlayers(), worlddata.getType(), worldserver.spigotConfig.viewDistance, flag1, !flag));
+        playerconnection.sendPacket(new PacketPlayOutLogin(entityplayer.getId(), entityplayer.playerInteractManager.getGameMode(), WorldData.c(worlddata.getSeed()), worlddata.isHardcore(), worldserver.worldProvider.getDimensionManager().getType(), this.getMaxPlayers(), worlddata.getType(), Math.max(entityplayer.getEffectiveViewDistance(worldserver.getChunkProvider().playerChunkMap), entityplayer.getEffectiveNoTickViewDistance(worldserver.getChunkProvider().playerChunkMap)), flag1, !flag)); // Tuinity - per player view distance
         entityplayer.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
         playerconnection.sendPacket(new PacketPlayOutCustomPayload(PacketPlayOutCustomPayload.a, (new PacketDataSerializer(Unpooled.buffer())).a(this.getServer().getServerModName())));
         playerconnection.sendPacket(new PacketPlayOutServerDifficulty(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
@@ -700,7 +700,7 @@ public abstract class PlayerList {
         WorldData worlddata = worldserver.getWorldData();
 
         entityplayer1.playerConnection.sendPacket(new PacketPlayOutRespawn(worldserver.worldProvider.getDimensionManager().getType(),  WorldData.c(worldserver.getWorldData().getSeed()), worldserver.getWorldData().getType(), entityplayer1.playerInteractManager.getGameMode()));
-        entityplayer1.playerConnection.sendPacket(new PacketPlayOutViewDistance(worldserver.spigotConfig.viewDistance)); // Spigot
+        entityplayer1.playerConnection.sendPacket(new PacketPlayOutViewDistance(Math.max(entityplayer1.getEffectiveViewDistance(worldserver.getChunkProvider().playerChunkMap), entityplayer1.getEffectiveNoTickViewDistance(worldserver.getChunkProvider().playerChunkMap)))); // Spigot // Tuinity - per player view distance
         entityplayer1.spawnIn(worldserver);
         entityplayer1.dead = false;
         entityplayer1.playerConnection.teleport(new Location(worldserver.getWorld(), entityplayer1.locX(), entityplayer1.locY(), entityplayer1.locZ(), entityplayer1.yaw, entityplayer1.pitch));
@@ -1178,7 +1178,7 @@ public abstract class PlayerList {
 
     public void a(int i) {
         this.viewDistance = i;
-        this.sendAll(new PacketPlayOutViewDistance(i));
+        //this.sendAll(new PacketPlayOutViewDistance(i)); // Tuinity - move into setViewDistance
         Iterator iterator = this.server.getWorlds().iterator();
 
         while (iterator.hasNext()) {
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index ec3f6822f76a68e8c47c3f4b6a38ad6a33074b3a..2b5d0ecd0d520b28a06483f01473a7c080bef808 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -442,8 +442,13 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
                 this.b(blockposition, iblockdata1, iblockdata2);
             }
 
-            if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || (chunk.getState() != null && chunk.getState().isAtLeast(PlayerChunk.State.TICKING)))) { // allow chunk to be null here as chunk.isReady() is false when we send our notification during block placement
+            if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || (chunk.getState() != null && chunk.getState().isAtLeast(PlayerChunk.State.TICKING)))) { // allow chunk to be null here as chunk.isReady() is false when we send our notification during block placement // Tuinity - diff on change, see below
                 this.notify(blockposition, iblockdata1, iblockdata, i);
+                // Tuinity start - per player view distance - allow block updates for non-ticking chunks in player view distance
+                // if copied from above
+            } else if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || ((WorldServer)this).getChunkProvider().playerChunkMap.playerViewDistanceBroadcastMap.getObjectsInRange(com.tuinity.tuinity.util.Util.getCoordinateKey(blockposition)) != null)) {
+                ((WorldServer)this).getChunkProvider().flagDirty(blockposition);
+                // Tuinity end - per player view distance
             }
 
             if (!this.isClientSide && (i & 1) != 0) {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 35507262b6d6b34d054868510c2ec0b4f45b1a2d..e89d8d0804302c59d7aa682a541381e06323b551 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -3,6 +3,7 @@ package org.bukkit.craftbukkit;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
+import com.tuinity.tuinity.util.TickThread;
 import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
 import java.io.File;
 import java.io.IOException;
@@ -2467,10 +2468,43 @@ public class CraftWorld implements World {
     // Spigot start
     @Override
     public int getViewDistance() {
-        return world.spigotConfig.viewDistance;
+        return getHandle().getChunkProvider().playerChunkMap.getViewDistance(); // Tuinity start - per player view distance
     }
     // Spigot end
 
+    // Tuinity start - per player view distance
+
+
+    @Override
+    public void setViewDistance(int viewDistance) {
+        TickThread.ensureTickThread("Cannot update view distance safely off of the main thread");
+        if (viewDistance < 2 || viewDistance > 32) {
+            throw new IllegalArgumentException("View distance " + viewDistance + " is out of range of [2, 32]");
+        }
+        net.minecraft.server.PlayerChunkMap chunkMap = getHandle().getChunkProvider().playerChunkMap;
+        if (viewDistance != chunkMap.getViewDistance()) {
+            chunkMap.setViewDistance(viewDistance);
+        }
+    }
+
+    @Override
+    public int getNoTickViewDistance() {
+        return getHandle().getChunkProvider().playerChunkMap.getNoTickViewDistance();
+    }
+
+    @Override
+    public void setNoTickViewDistance(int viewDistance) {
+        TickThread.ensureTickThread("Cannot update view distance safely off of the main thread");
+        if (viewDistance < 2 || viewDistance > 32) {
+            throw new IllegalArgumentException("View distance " + viewDistance + " is out of range of [2, 32]");
+        }
+        net.minecraft.server.PlayerChunkMap chunkMap = getHandle().getChunkProvider().playerChunkMap;
+        if (viewDistance != chunkMap.getNoTickViewDistance()) {
+            chunkMap.setNoTickViewDistance(viewDistance);
+        }
+    }
+    // Tuinity end - per player view distance
+
     // Spigot start
     private final Spigot spigot = new Spigot()
     {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 60f62f19cbc2c115fe7bf399877b774e6d72bdb5..651ff6647398747199cbfcc5f49b8ccd707609af 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -1,5 +1,6 @@
 package org.bukkit.craftbukkit.entity;
 
+import com.tuinity.tuinity.util.TickThread; // Tuinity
 import com.destroystokyo.paper.Title;
 import com.destroystokyo.paper.profile.CraftPlayerProfile;
 import com.destroystokyo.paper.profile.PlayerProfile;
@@ -1997,13 +1998,39 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public int getViewDistance() {
-        throw new NotImplementedException("Per-Player View Distance APIs need further understanding to properly implement"); // TODO
+        return getHandle().getEffectiveViewDistance(); // Tuinity - per player view distance
     }
 
     @Override
     public void setViewDistance(int viewDistance) {
-        throw new NotImplementedException("Per-Player View Distance APIs need further understanding to properly implement"); // TODO
+        // Tuinity start - per player view distance
+        TickThread.ensureTickThread("Cannot update view distance safely off of the main thread");
+        if ((viewDistance < 2 || viewDistance > 32) && viewDistance != -1) {
+            throw new IllegalArgumentException("View distance " + viewDistance + " is out of range of [2, 32]");
+        }
+        if (viewDistance != getHandle().getRawViewDistance()) {
+            ((WorldServer)getHandle().world).getChunkProvider().playerChunkMap.updateViewDistance(getHandle(), viewDistance, getHandle().getRawNoTickViewDistance());
+        }
+        // Tuinity end - per player view distance
+    }
+
+    // Tuinity start - per player view distance
+    @Override
+    public int getNoTickViewDistance() {
+        return getHandle().getEffectiveNoTickViewDistance();
+    }
+
+    @Override
+    public void setNoTickViewDistance(int viewDistance) {
+        TickThread.ensureTickThread("Cannot update view distance safely off of the main thread");
+        if ((viewDistance < 2 || viewDistance > 32) && viewDistance != -1) {
+            throw new IllegalArgumentException("View distance " + viewDistance + " is out of range of [2, 32]");
+        }
+        if (viewDistance != getHandle().getRawNoTickViewDistance()) {
+            ((WorldServer)getHandle().world).getChunkProvider().playerChunkMap.updateViewDistance(getHandle(), getHandle().getRawViewDistance(), viewDistance);
+        }
     }
+    // Tuinity end - per player view distance
     // Paper end
 
     // Spigot start
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
index 795817177aae00a5157ae77b2192841c8d028732..f6e8f7d9c64bf8f34b13636e4d0e13746fd2c4f4 100644
--- a/src/main/java/org/spigotmc/ActivationRange.java
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -46,6 +46,7 @@ import net.minecraft.server.EntityInsentient;
 import net.minecraft.server.EntityLlama;
 import net.minecraft.server.EntityWaterAnimal;
 // Paper end
+import net.minecraft.server.WorldServer; // Tuinity
 
 public class ActivationRange
 {
@@ -137,14 +138,15 @@ public class ActivationRange
         final int waterActivationRange = world.spigotConfig.waterActivationRange; // Paper
         final ChunkProviderServer chunkProvider = (ChunkProviderServer) world.getChunkProvider(); // Paper
 
-        int maxRange = Math.max( monsterActivationRange, animalActivationRange );
-        maxRange = Math.max( maxRange, raiderActivationRange );
-        maxRange = Math.max( maxRange, miscActivationRange );
-        maxRange = Math.min( ( world.spigotConfig.viewDistance << 4 ) - 8, maxRange );
+        // Tuinity start - per player view distance
+        int maxRangeTemp = Math.max( monsterActivationRange, animalActivationRange );
+        maxRangeTemp = Math.max( maxRangeTemp, raiderActivationRange );
+        maxRangeTemp = Math.max( maxRangeTemp, miscActivationRange );
 
         for ( EntityHuman player : world.getPlayers() )
         {
-
+            final int maxRange = Math.min( ( ( player instanceof net.minecraft.server.EntityPlayer ? ((net.minecraft.server.EntityPlayer)player).getEffectiveViewDistance(((WorldServer)world).getChunkProvider().playerChunkMap) : world.spigotConfig.viewDistance ) << 4 ) - 8, maxRangeTemp );
+            // Tuinity end - per player view distance
             player.activatedTick = MinecraftServer.currentTick;
             maxBB = player.getBoundingBox().grow( maxRange, 256, maxRange );
             ActivationType.MISC.boundingBox = player.getBoundingBox().grow( miscActivationRange, 256, miscActivationRange );
