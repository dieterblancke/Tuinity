From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Tue, 27 Aug 2019 15:08:24 -0700
Subject: [PATCH] Remove logic creating lots of garbage on the heap

- PathfinderGoalSelector showed up at the top in memory profiling due
to streams

- ChunkMapDistance showed up at the top too due to bad iterator usage

- PlayerChunkMap#move and ChunkMap showed near the top when moving
around due to avoidable ChunkCoordIntPair allocations

- PathFinderNormal allocates a block position when checking the path
type of a block

- Either.Left/Right do not cache the optional returned for left()/right()
 (getChunk type calls all have to go through them...)

- ObjectAVLTreeSet does not override removeIf, so the default uses
an iterator. removeIf is invoked heavily in ChunkMapDistance (on every
tick). Replace with an impl that caches the iterator

- Some lighting stuff allocating AtomicInteger for passing a second
return value from a function. use a field since the JIT is not stack
allocating the variable

- Randomly ticking a block would allocate a BlockPosition, replace
with mutable pos

- Entity iteration for ticking would use a non-fast iterator, thus
creating lots of garbage entries.

- Replace how the chunk map and light data is updated
   Before the underlying maps were copy on write, however this obviously
   will not scale well at all for large player counts. The replacement is
   a system which will queue updates to a map locked by a seqlock.
   Intentionally, the constructors/fields were clobbered, breaking
   the ABI.

- Vec3d allocation by tracker for checking a simple delta

- Iterator usage in hot areas

- Entry iteration in LightEngineStorage
   Fast iterator might look like it could not be used since that's only p
   rovided via the Long2ObjectOpenHashMap interface, and the map was
   synchronized via Long2ObjectMaps.synchronize - however the
   synchronized map does not wrap the iterator, so we can freely
   use the fast iterator without causing synchronization
   issues. Also target next() vs nextLong(), although they really
   did not show up in the profiler at all.

- Iterator creation in ProtoChunk#setType
   Avoid using an array

diff --git a/src/main/java/com/destroystokyo/paper/PaperCommand.java b/src/main/java/com/destroystokyo/paper/PaperCommand.java
index dfe92780ad288dd12f961ccad3e9f6f12b24287e..c088cf51ffcec243cf284e049a2b458d12b180ca 100644
--- a/src/main/java/com/destroystokyo/paper/PaperCommand.java
+++ b/src/main/java/com/destroystokyo/paper/PaperCommand.java
@@ -215,7 +215,7 @@ public class PaperCommand extends Command {
             int ticking = 0;
             int entityTicking = 0;
 
-            for (PlayerChunk chunk : world.getChunkProvider().playerChunkMap.updatingChunks.values()) {
+            for (PlayerChunk chunk : world.getChunkProvider().playerChunkMap.chunkMap.getUpdatingValues()) { // Tuinity - replace chunk map
                 if (chunk.getFullChunkIfCached() == null) {
                     continue;
                 }
diff --git a/src/main/java/com/mojang/datafixers/util/Either.java b/src/main/java/com/mojang/datafixers/util/Either.java
index a90adac7bd7ebd423f480e9ae0f44cb9d521fa4f..2e7cbf8bf5d1a31208940cefa74b630a953e2785 100644
--- a/src/main/java/com/mojang/datafixers/util/Either.java
+++ b/src/main/java/com/mojang/datafixers/util/Either.java
@@ -23,6 +23,7 @@ public abstract class Either<L, R> implements App<Either.Mu<R>, L> {
 
     private static final class Left<L, R> extends Either<L, R> {
         private final L value;
+        private Optional<L> cachedLeft; // Tuinity - reduce allocation of these for chunks...
 
         public Left(final L value) {
             this.value = value;
@@ -51,7 +52,7 @@ public abstract class Either<L, R> implements App<Either.Mu<R>, L> {
 
         @Override
         public Optional<L> left() {
-            return Optional.of(value);
+            return this.cachedLeft == null ? this.cachedLeft = Optional.of(value) : this.cachedLeft; // Tuinity - cache optional
         }
 
         @Override
@@ -84,6 +85,7 @@ public abstract class Either<L, R> implements App<Either.Mu<R>, L> {
 
     private static final class Right<L, R> extends Either<L, R> {
         private final R value;
+        private Optional<R> cachedRight; // Tuinity - reduce allocation of these for chunks...
 
         public Right(final R value) {
             this.value = value;
@@ -117,7 +119,7 @@ public abstract class Either<L, R> implements App<Either.Mu<R>, L> {
 
         @Override
         public Optional<R> right() {
-            return Optional.of(value);
+            return this.cachedRight == null ? this.cachedRight = Optional.of(value) : this.cachedRight; // Tuinity - cache optional
         }
 
         @Override
diff --git a/src/main/java/com/tuinity/tuinity/util/fastutil/ExtendedAbstractDoubleList.java b/src/main/java/com/tuinity/tuinity/util/fastutil/ExtendedAbstractDoubleList.java
new file mode 100644
index 0000000000000000000000000000000000000000..88b198fd7bccdaa294ab436ede0242c028f744c4
--- /dev/null
+++ b/src/main/java/com/tuinity/tuinity/util/fastutil/ExtendedAbstractDoubleList.java
@@ -0,0 +1,39 @@
+package com.tuinity.tuinity.util.fastutil;
+
+import it.unimi.dsi.fastutil.doubles.AbstractDoubleList;
+import it.unimi.dsi.fastutil.doubles.DoubleList;
+
+import java.util.List;
+
+public abstract class ExtendedAbstractDoubleList extends AbstractDoubleList {
+
+    @Override
+    public boolean equals(final Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof DoubleList)) {
+            if (other instanceof List) {
+                return super.equals(other);
+            }
+            return false;
+        }
+
+        final DoubleList otherList = (DoubleList)other;
+
+        final int otherSize = otherList.size();
+        final int thisSize = this.size();
+
+        if (otherSize != thisSize) {
+            return false;
+        }
+
+        for (int i = 0; i < thisSize; ++i) {
+            if (this.getDouble(i) != otherList.getDouble(i)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/tuinity/tuinity/util/fastutil/ExtendedDoubleArrayList.java b/src/main/java/com/tuinity/tuinity/util/fastutil/ExtendedDoubleArrayList.java
new file mode 100644
index 0000000000000000000000000000000000000000..36457981ee9599a8c291e77f60f387f4f00ba764
--- /dev/null
+++ b/src/main/java/com/tuinity/tuinity/util/fastutil/ExtendedDoubleArrayList.java
@@ -0,0 +1,65 @@
+package com.tuinity.tuinity.util.fastutil;
+
+import it.unimi.dsi.fastutil.doubles.DoubleArrayList;
+import it.unimi.dsi.fastutil.doubles.DoubleList;
+
+import java.util.Arrays;
+import java.util.List;
+
+public class ExtendedDoubleArrayList extends DoubleArrayList {
+
+    public ExtendedDoubleArrayList() {
+        super();
+    }
+
+    public ExtendedDoubleArrayList(final int capacity) {
+        super(capacity);
+    }
+
+    public ExtendedDoubleArrayList(final double[] array) {
+        this(array, array.length, true);
+    }
+
+    public ExtendedDoubleArrayList(final double[] array, final int size, final boolean copy) {
+        super(copy ? array.clone() : array, false);
+        this.size = size;
+    }
+
+    public static ExtendedDoubleArrayList getList(final double[] list, final int requiredLength) {
+        if (list.length == requiredLength) {
+            return new ExtendedDoubleArrayList(list, requiredLength, false);
+        } else {
+            return new ExtendedDoubleArrayList(Arrays.copyOf(list, requiredLength), requiredLength, false);
+        }
+    }
+
+    @Override
+    public boolean equals(final Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof DoubleList)) {
+            if (other instanceof List) {
+                return super.equals(other);
+            }
+            return false;
+        }
+
+        final DoubleList otherList = (DoubleList)other;
+
+        final int otherSize = otherList.size();
+        final int thisSize = this.size();
+
+        if (otherSize != thisSize) {
+            return false;
+        }
+
+        for (int i = 0; i < thisSize; ++i) {
+            if (this.getDouble(i) != otherList.getDouble(i)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+}
diff --git a/src/main/java/com/tuinity/tuinity/util/fastutil/ExtendedObjectAVLTreeSet.java b/src/main/java/com/tuinity/tuinity/util/fastutil/ExtendedObjectAVLTreeSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..1a3f5963309f3464c7c8a37e0c46ab74165af88e
--- /dev/null
+++ b/src/main/java/com/tuinity/tuinity/util/fastutil/ExtendedObjectAVLTreeSet.java
@@ -0,0 +1,90 @@
+package com.tuinity.tuinity.util.fastutil;
+
+import it.unimi.dsi.fastutil.objects.ObjectAVLTreeSet;
+import it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator;
+
+import java.lang.reflect.Field;
+import java.util.function.Predicate;
+
+public class ExtendedObjectAVLTreeSet<K> extends ObjectAVLTreeSet<K> {
+
+    private static final Field PREV_FIELD;
+    private static final Field NEXT_FIELD;
+    private static final Field CURR_FIELD;
+    private static final Field INDEX_FIELD;
+
+    private static final Integer ZERO = Integer.valueOf(0);
+
+    static {
+        try {
+            final Class clazz = Class.forName(ObjectAVLTreeSet.class.getCanonicalName() + "$SetIterator");
+            PREV_FIELD = clazz.getDeclaredField("prev");
+            PREV_FIELD.setAccessible(true);
+
+            NEXT_FIELD = clazz.getDeclaredField("next");
+            NEXT_FIELD.setAccessible(true);
+
+            CURR_FIELD = clazz.getDeclaredField("curr");
+            CURR_FIELD.setAccessible(true);
+
+            INDEX_FIELD = clazz.getDeclaredField("index");
+            INDEX_FIELD.setAccessible(true);
+        } catch (final Throwable thr) {
+            throw new RuntimeException(thr);
+        }
+    }
+
+    private ObjectBidirectionalIterator<K> cachedIterator = this.iterator();
+
+    {
+        this.nullIterator(this.cachedIterator);
+    }
+
+    @Override
+    public boolean removeIf(Predicate<? super K> filter) {
+        if (this.isEmpty()) {
+            return false;
+        }
+
+        if (this.cachedIterator == null) {
+            return super.removeIf(filter); // recursive...?
+        }
+
+        final ObjectBidirectionalIterator<K> iterator = this.cachedIterator;
+        this.cachedIterator = null;
+        this.startIterator(iterator);
+
+        boolean ret = false;
+
+        while (iterator.hasNext()) {
+            if (filter.test(iterator.next())) {
+                ret = true;
+                iterator.remove();
+            }
+        }
+
+        this.nullIterator(iterator);
+        this.cachedIterator = iterator;
+        return ret;
+    }
+
+    private void startIterator(final ObjectBidirectionalIterator<K> iterator) {
+        // assume iterator is null'd
+        try {
+            NEXT_FIELD.set(iterator, this.firstEntry);
+        } catch (final IllegalAccessException ex) {
+            throw new RuntimeException(ex); // not going to occur
+        }
+    }
+
+    private void nullIterator(final ObjectBidirectionalIterator<K> iterator) {
+        try {
+            PREV_FIELD.set(iterator, null);
+            NEXT_FIELD.set(iterator, null);
+            CURR_FIELD.set(iterator, null);
+            INDEX_FIELD.set(iterator, ZERO);
+        } catch (final IllegalAccessException ex) {
+            throw new RuntimeException(ex); // not going to occur
+        }
+    }
+}
diff --git a/src/main/java/com/tuinity/tuinity/util/pool/PooledBlockPositions.java b/src/main/java/com/tuinity/tuinity/util/pool/PooledBlockPositions.java
new file mode 100644
index 0000000000000000000000000000000000000000..815974682ae0c6b0f1cf567b6fdc90017498da50
--- /dev/null
+++ b/src/main/java/com/tuinity/tuinity/util/pool/PooledBlockPositions.java
@@ -0,0 +1,40 @@
+package com.tuinity.tuinity.util.pool;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.MinecraftServer;
+
+public class PooledBlockPositions {
+
+    private static final int BLOCK_POOL_SIZE = 8192;
+
+    private static final BlockPosition.MutableBlockPosition[] POOL = new BlockPosition.MutableBlockPosition[BLOCK_POOL_SIZE];
+    private static int used = 0; // exclusive index of used positions
+
+    static {
+        for (int i = 0; i < BLOCK_POOL_SIZE; ++i) {
+            POOL[i] = new BlockPosition.MutableBlockPosition();
+        }
+    }
+
+    public static BlockPosition.MutableBlockPosition get(final int x, final int y, final int z) {
+        final int currentUsed = used;
+        if (Thread.currentThread() != MinecraftServer.getServer().serverThread || currentUsed >= POOL.length) {
+            return new BlockPosition.MutableBlockPosition(x, y, z);
+        }
+        used = currentUsed + 1;
+
+        final BlockPosition.MutableBlockPosition ret = POOL[currentUsed];
+        POOL[currentUsed] = null;
+
+        return ret.setValues(x, y, z);
+    }
+
+    public static void ret(final BlockPosition.MutableBlockPosition position) {
+        final int currentUsed = used;
+        if (Thread.currentThread() != MinecraftServer.getServer().serverThread || currentUsed == 0) {
+            return;
+        }
+
+        POOL[used = currentUsed - 1] = position;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ChunkMap.java b/src/main/java/net/minecraft/server/ChunkMap.java
index 55f9f4e6e7fddb2fcdbc1877d1bdfe8d3c9eff6f..24ba03ae580858fde7c32c915bb447b97ea229a6 100644
--- a/src/main/java/net/minecraft/server/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/ChunkMap.java
@@ -13,9 +13,10 @@ public abstract class ChunkMap extends LightEngineGraph {
 
     @Override
     protected void a(long i, int j, boolean flag) {
-        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i);
-        int k = chunkcoordintpair.x;
-        int l = chunkcoordintpair.z;
+        // Tuinity start - remove allocation of ChunkCoordIntPair
+        int k = ChunkCoordIntPair.getX(i);
+        int l = ChunkCoordIntPair.getZ(i);
+        // Tuinity end
 
         for (int i1 = -1; i1 <= 1; ++i1) {
             for (int j1 = -1; j1 <= 1; ++j1) {
@@ -32,9 +33,10 @@ public abstract class ChunkMap extends LightEngineGraph {
     @Override
     protected int a(long i, long j, int k) {
         int l = k;
-        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i);
-        int i1 = chunkcoordintpair.x;
-        int j1 = chunkcoordintpair.z;
+        // Tuinity start - remove allocation of ChunkCoordIntPair
+        int i1 = ChunkCoordIntPair.getX(i);
+        int j1 = ChunkCoordIntPair.getZ(i);
+        // Tuinity end
 
         for (int k1 = -1; k1 <= 1; ++k1) {
             for (int l1 = -1; l1 <= 1; ++l1) {
diff --git a/src/main/java/net/minecraft/server/ChunkMapDistance.java b/src/main/java/net/minecraft/server/ChunkMapDistance.java
index 8fa9b268b8e61b5e9d971bb3ef095742bf0d1c6f..f92b429e8644364a667648b680f086c08bcb3d31 100644
--- a/src/main/java/net/minecraft/server/ChunkMapDistance.java
+++ b/src/main/java/net/minecraft/server/ChunkMapDistance.java
@@ -356,7 +356,7 @@ public abstract class ChunkMapDistance {
         }
 
         public void a(int i) {
-            ObjectIterator objectiterator = this.a.long2ByteEntrySet().iterator();
+            ObjectIterator objectiterator = this.a.long2ByteEntrySet().fastIterator(); // Tuinity - use fast iterator (reduces entry creation)
 
             while (objectiterator.hasNext()) {
                 it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry it_unimi_dsi_fastutil_longs_long2bytemap_entry = (it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry) objectiterator.next();
@@ -437,7 +437,7 @@ public abstract class ChunkMapDistance {
 
     class b extends ChunkMap {
 
-        protected final Long2ByteMap a = new Long2ByteOpenHashMap();
+        protected final Long2ByteOpenHashMap a = new Long2ByteOpenHashMap(); // Tuinity - change type for fast iterator
         protected final int b;
 
         protected b(int i) {
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index aff61c2c8cb71d715085171c081d4205df71eb73..1cb9e9f291ec936a94dc0ad71330cb1ccda9260e 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -616,6 +616,12 @@ public class ChunkProviderServer extends IChunkProvider {
         this.clearCache();
     }
 
+    // Tuinity start
+    final com.tuinity.tuinity.util.ChunkList entityTickingChunks = new com.tuinity.tuinity.util.ChunkList();
+    boolean isTickingChunks;
+    final it.unimi.dsi.fastutil.objects.Object2BooleanLinkedOpenHashMap<Chunk> pendingEntityTickingChunkChanges = new it.unimi.dsi.fastutil.objects.Object2BooleanLinkedOpenHashMap<>(16, 0.8f);
+    // Tuinity end
+
     private void tickChunks() {
         long i = this.world.getTime();
         long j = i - this.lastTickTime;
@@ -668,11 +674,12 @@ public class ChunkProviderServer extends IChunkProvider {
                 entityPlayer.playerNaturallySpawnedEvent.callEvent();
             };
             // Paper end
-            this.playerChunkMap.f().forEach((playerchunk) -> {
-                Optional<Chunk> optional = ((Either) playerchunk.b().getNow(PlayerChunk.UNLOADED_CHUNK)).left();
-
-                if (optional.isPresent()) {
-                    Chunk chunk = (Chunk) optional.get();
+            // Tuinity start - replace chunk map
+            this.isTickingChunks = true;
+            for (Chunk chunk : this.entityTickingChunks) {
+                PlayerChunk playerchunk = chunk.playerChunk;
+                if (playerchunk != null) { // make sure load event has been called along with the load logic we put there
+                    // Tuinity end
 
                     this.world.getMethodProfiler().enter("broadcast");
                     this.world.timings.broadcastChunkUpdates.startTiming(); // Paper - timings
@@ -767,7 +774,22 @@ public class ChunkProviderServer extends IChunkProvider {
                         this.world.timings.chunkTicks.stopTiming(); // Spigot // Paper
                     }
                 }
-            });
+            }; // Tuinity
+            // Tuinity start - replace chunk map
+            this.isTickingChunks = false;
+            if (!this.pendingEntityTickingChunkChanges.isEmpty()) {
+                for (it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator<it.unimi.dsi.fastutil.objects.Object2BooleanMap.Entry<Chunk>> iterator = this.pendingEntityTickingChunkChanges.object2BooleanEntrySet().fastIterator(this.pendingEntityTickingChunkChanges.object2BooleanEntrySet().last()); iterator.hasPrevious(); ) {
+                    it.unimi.dsi.fastutil.objects.Object2BooleanMap.Entry<Chunk> entry = iterator.previous();
+
+                    if (entry.getBooleanValue()) {
+                        this.entityTickingChunks.add(entry.getKey());
+                    } else {
+                        this.entityTickingChunks.remove(entry.getKey());
+                    }
+                    iterator.remove();
+                }
+            }
+            // Tuinity end - replace chunk map
             this.world.getMethodProfiler().enter("customSpawners");
             if (flag1) {
                 try (co.aikar.timings.Timing ignored = this.world.timings.miscMobSpawning.startTiming()) { // Paper - timings
diff --git a/src/main/java/net/minecraft/server/ChunkStatus.java b/src/main/java/net/minecraft/server/ChunkStatus.java
index 88f1674616ef0af9d7491402ce672125f4b7fe83..25654520e7300fe5b1a4e5c445fcb142aa139bcf 100644
--- a/src/main/java/net/minecraft/server/ChunkStatus.java
+++ b/src/main/java/net/minecraft/server/ChunkStatus.java
@@ -103,7 +103,7 @@ public class ChunkStatus {
     private final ChunkStatus.c w;
     private final int x;
     private final ChunkStatus.Type y;
-    private final EnumSet<HeightMap.Type> z;
+    private final EnumSet<HeightMap.Type> z; public final HeightMap.Type[] heightMaps; // Tuinity
 
     private static CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> a(ChunkStatus chunkstatus, LightEngineThreaded lightenginethreaded, IChunkAccess ichunkaccess) {
         boolean flag = a(chunkstatus, ichunkaccess);
@@ -165,7 +165,7 @@ public class ChunkStatus {
         this.w = chunkstatus_c;
         this.x = i;
         this.y = chunkstatus_type;
-        this.z = enumset;
+        this.z = enumset; this.heightMaps = new java.util.ArrayList<>(this.z).toArray(new HeightMap.Type[0]); // Tuinity
         this.t = chunkstatus == null ? 0 : chunkstatus.c() + 1;
     }
 
diff --git a/src/main/java/net/minecraft/server/DoubleListOffset.java b/src/main/java/net/minecraft/server/DoubleListOffset.java
index 73657f740731b9bc606e64d0a2a3f32a842db3f5..9ff09b02d6d0f26d935797f41eb99ec7a9c3d94f 100644
--- a/src/main/java/net/minecraft/server/DoubleListOffset.java
+++ b/src/main/java/net/minecraft/server/DoubleListOffset.java
@@ -3,7 +3,7 @@ package net.minecraft.server;
 import it.unimi.dsi.fastutil.doubles.AbstractDoubleList;
 import it.unimi.dsi.fastutil.doubles.DoubleList;
 
-public class DoubleListOffset extends AbstractDoubleList {
+public class DoubleListOffset extends com.tuinity.tuinity.util.fastutil.ExtendedAbstractDoubleList { // Tuinity - remove iterator allocation
 
     private final DoubleList a;
     private final double b;
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index ce619980ca9bc87555a7f95e0574290fc6b1f760..0e1bd031f7f6a65381b2e3f1e136e608608348a2 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -1785,8 +1785,13 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     }
 
     public void a(ChunkCoordIntPair chunkcoordintpair) {
+        // Tuinity start - remove ChunkCoordIntPair allocation
+        this.sendChunkUnload(chunkcoordintpair.x, chunkcoordintpair.z);
+    }
+    public final void sendChunkUnload(int x, int z) {
+        // Tuinity end - remove ChunkCoordIntPair allocation
         if (this.isAlive()) {
-            this.playerConnection.sendPacket(new PacketPlayOutUnloadChunk(chunkcoordintpair.x, chunkcoordintpair.z));
+            this.playerConnection.sendPacket(new PacketPlayOutUnloadChunk(x, z)); // Tuinity
         }
 
     }
diff --git a/src/main/java/net/minecraft/server/EntityTrackerEntry.java b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
index 3e5d6a9e151fb990b777c1ac48cabea653ea1c27..40d6e8bf7c34d91bbc44d23efc498daa4f61b7e2 100644
--- a/src/main/java/net/minecraft/server/EntityTrackerEntry.java
+++ b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
@@ -125,8 +125,10 @@ public class EntityTrackerEntry {
                 ++this.o;
                 i = MathHelper.d(this.tracker.yaw * 256.0F / 360.0F);
                 j = MathHelper.d(this.tracker.pitch * 256.0F / 360.0F);
-                Vec3D vec3d = this.tracker.getPositionVector().d(PacketPlayOutEntity.a(this.xLoc, this.yLoc, this.zLoc));
-                boolean flag1 = vec3d.g() >= 7.62939453125E-6D;
+                double vec3d_dx = this.tracker.locX() - 2.44140625E-4D*(this.xLoc);
+                double vec3d_dy = this.tracker.locY() - 2.44140625E-4D*(this.yLoc);
+                double vec3d_dz = this.tracker.locZ() - 2.44140625E-4D*(this.zLoc);
+                boolean flag1 = (vec3d_dx * vec3d_dx + vec3d_dy * vec3d_dy + vec3d_dz * vec3d_dz) >= 7.62939453125E-6D;
                 Packet<?> packet1 = null;
                 boolean flag2 = flag1 || this.tickCounter % 60 == 0;
                 boolean flag3 = Math.abs(i - this.yRot) >= 1 || Math.abs(j - this.xRot) >= 1;
@@ -143,9 +145,11 @@ public class EntityTrackerEntry {
                 // CraftBukkit end
 
                 if (this.tickCounter > 0 || this.tracker instanceof EntityArrow) {
-                    long k = PacketPlayOutEntity.a(vec3d.x);
-                    long l = PacketPlayOutEntity.a(vec3d.y);
-                    long i1 = PacketPlayOutEntity.a(vec3d.z);
+                    // Tuinity start - remove allocation of Vec3d here
+                    long k = PacketPlayOutEntity.a(vec3d_dx);
+                    long l = PacketPlayOutEntity.a(vec3d_dy);
+                    long i1 = PacketPlayOutEntity.a(vec3d_dz);
+                    // Tuinity end - remove allocation of Vec3d here
                     boolean flag4 = k < -32768L || k > 32767L || l < -32768L || l > 32767L || i1 < -32768L || i1 > 32767L;
 
                     if (!flag4 && this.o <= 400 && !this.q && this.r == this.tracker.onGround) {
diff --git a/src/main/java/net/minecraft/server/LightEngineBlock.java b/src/main/java/net/minecraft/server/LightEngineBlock.java
index 93a972605c26aa757b9c915876f847da04fcb496..43424c88ab830281bcfd7594e1100831050ec608 100644
--- a/src/main/java/net/minecraft/server/LightEngineBlock.java
+++ b/src/main/java/net/minecraft/server/LightEngineBlock.java
@@ -37,7 +37,7 @@ public final class LightEngineBlock extends LightEngineLayer<LightEngineStorageB
             if (enumdirection == null) {
                 return 15;
             } else {
-                MutableInt mutableint = new MutableInt();
+                MutableInt mutableint = this.lastLevel; // Tuinity - avoid allocation of MutableInt
                 IBlockData iblockdata = this.a(j, mutableint);
 
                 if (mutableint.getValue() >= 15) {
diff --git a/src/main/java/net/minecraft/server/LightEngineLayer.java b/src/main/java/net/minecraft/server/LightEngineLayer.java
index f72ff8495bcf704c15040676b95c51fecb72b73a..f27a148731fb71f85265396b345c6306a1f1b2d0 100644
--- a/src/main/java/net/minecraft/server/LightEngineLayer.java
+++ b/src/main/java/net/minecraft/server/LightEngineLayer.java
@@ -11,7 +11,7 @@ public abstract class LightEngineLayer<M extends LightEngineStorageArray<M>, S e
     protected final EnumSkyBlock b;
     protected final S c;
     private boolean f;
-    protected final BlockPosition.MutableBlockPosition d = new BlockPosition.MutableBlockPosition();
+    protected final BlockPosition.MutableBlockPosition d = new BlockPosition.MutableBlockPosition(); protected final MutableInt lastLevel = new MutableInt(); // Tuinity - avoid allocating MutableInt
     private final long[] g = new long[2];
     private final IBlockAccess[] h = new IBlockAccess[2];
 
diff --git a/src/main/java/net/minecraft/server/LightEngineSky.java b/src/main/java/net/minecraft/server/LightEngineSky.java
index 2301a982e17ab9568e3da9ca84c4a024c7c1b214..488d4f289f0934022c7fb040350eb1450e8cc167 100644
--- a/src/main/java/net/minecraft/server/LightEngineSky.java
+++ b/src/main/java/net/minecraft/server/LightEngineSky.java
@@ -27,7 +27,7 @@ public final class LightEngineSky extends LightEngineLayer<LightEngineStorageSky
             if (k >= 15) {
                 return k;
             } else {
-                MutableInt mutableint = new MutableInt();
+                MutableInt mutableint = this.lastLevel; // Tuinity - avoid allocation of MutableInt
                 IBlockData iblockdata = this.a(j, mutableint);
 
                 if (mutableint.getValue() >= 15) {
diff --git a/src/main/java/net/minecraft/server/LightEngineStorage.java b/src/main/java/net/minecraft/server/LightEngineStorage.java
index a3f919816eb2a742ed09b553995e6508684e5ea5..dacc96414f6b381700c72a0f61af3f8e517a2b62 100644
--- a/src/main/java/net/minecraft/server/LightEngineStorage.java
+++ b/src/main/java/net/minecraft/server/LightEngineStorage.java
@@ -19,11 +19,12 @@ public abstract class LightEngineStorage<M extends LightEngineStorageArray<M>> e
     protected final LongSet b = new LongOpenHashSet();
     protected final LongSet c = new LongOpenHashSet();
     protected final LongSet d = new LongOpenHashSet();
-    protected volatile M e;
-    protected final M f;
+    protected volatile M e; // Tuinity - diff on change, should be "visible"
+    protected final M f; // Tuinity - diff on change, should be "updating"
     protected final LongSet g = new LongOpenHashSet();
     protected final LongSet h = new LongOpenHashSet();
-    protected final Long2ObjectMap<NibbleArray> i = Long2ObjectMaps.synchronize(new Long2ObjectOpenHashMap());
+    protected final Long2ObjectOpenHashMap<NibbleArray> synchronized_map_real = new Long2ObjectOpenHashMap<>(); // Tuinity - store wrapped map, we need fastIterator
+    protected final Long2ObjectMap<NibbleArray> i = Long2ObjectMaps.synchronize(this.synchronized_map_real); // Tuinity - store wrapped map, we need fastIterator
     private final LongSet n = new LongOpenHashSet();
     private final LongSet o = new LongOpenHashSet();
     protected volatile boolean j;
@@ -178,7 +179,7 @@ public abstract class LightEngineStorage<M extends LightEngineStorageArray<M>> e
             NibbleArray nibblearray;
 
             while (longiterator.hasNext()) {
-                i = (Long) longiterator.next();
+                i = longiterator.nextLong(); // Tuinity - use nextLong
                 this.a(lightenginelayer, i);
                 NibbleArray nibblearray1 = (NibbleArray) this.i.remove(i);
 
@@ -196,13 +197,13 @@ public abstract class LightEngineStorage<M extends LightEngineStorageArray<M>> e
             longiterator = this.o.iterator();
 
             while (longiterator.hasNext()) {
-                i = (Long) longiterator.next();
+                i = longiterator.nextLong(); // Tuinity - use nextLong
                 this.l(i);
             }
 
             this.o.clear();
             this.j = false;
-            ObjectIterator objectiterator = this.i.long2ObjectEntrySet().iterator();
+            ObjectIterator objectiterator = this.synchronized_map_real.long2ObjectEntrySet().fastIterator(); // Tuinity - use fast iterator to reduce entry creation
 
             Entry entry;
             long j;
@@ -225,7 +226,7 @@ public abstract class LightEngineStorage<M extends LightEngineStorageArray<M>> e
                 longiterator = this.i.keySet().iterator();
 
                 while (longiterator.hasNext()) {
-                    i = (Long) longiterator.next();
+                    i = longiterator.nextLong(); // Tuinity - use nextLong
                     if (this.g(i)) {
                         int k = SectionPosition.c(SectionPosition.b(i));
                         int l = SectionPosition.c(SectionPosition.c(i));
@@ -279,7 +280,7 @@ public abstract class LightEngineStorage<M extends LightEngineStorageArray<M>> e
                 }
             }
 
-            objectiterator = this.i.long2ObjectEntrySet().iterator();
+            objectiterator = this.synchronized_map_real.long2ObjectEntrySet().fastIterator(); // Tuinity - use fast iterator to avoid entry creation
 
             while (objectiterator.hasNext()) {
                 entry = (Entry) objectiterator.next();
diff --git a/src/main/java/net/minecraft/server/LightEngineStorageArray.java b/src/main/java/net/minecraft/server/LightEngineStorageArray.java
index b978723a66d001f70325df0c7521025e079d7cfa..5e2051ee1a27b56db010d1ffc16c7e1c1d6d7564 100644
--- a/src/main/java/net/minecraft/server/LightEngineStorageArray.java
+++ b/src/main/java/net/minecraft/server/LightEngineStorageArray.java
@@ -8,10 +8,17 @@ public abstract class LightEngineStorageArray<M extends LightEngineStorageArray<
     private final long[] b = new long[2];
     private final NibbleArray[] c = new NibbleArray[2];
     private boolean d;
-    protected final Long2ObjectOpenHashMap<NibbleArray> a;
+    protected final com.tuinity.tuinity.chunk.QueuedChangesMapLong2Object<NibbleArray> data; // Tuinity - avoid copying light data
+    protected final boolean isVisible; // Tuinity - avoid copying light data
 
-    protected LightEngineStorageArray(Long2ObjectOpenHashMap<NibbleArray> long2objectopenhashmap) {
-        this.a = long2objectopenhashmap;
+    // Tuinity start - avoid copying light data
+    protected LightEngineStorageArray(com.tuinity.tuinity.chunk.QueuedChangesMapLong2Object<NibbleArray> data, boolean isVisible) {
+        if (isVisible) {
+            data.performUpdatesLockMap();
+        }
+        this.data = data;
+        this.isVisible = isVisible;
+        // Tuinity end - avoid copying light data
         this.c();
         this.d = true;
     }
@@ -19,12 +26,13 @@ public abstract class LightEngineStorageArray<M extends LightEngineStorageArray<
     public abstract M b();
 
     public void a(long i) {
-        this.a.put(i, ((NibbleArray) this.a.get(i)).b());
+        if (this.isVisible) { throw new IllegalStateException("writing to visible data"); } // Tuinity - avoid copying light data
+        this.data.queueUpdate(i, ((NibbleArray) this.data.getUpdating(i)).b()); // Tuinity - avoid copying light data
         this.c();
     }
 
     public boolean b(long i) {
-        return this.a.containsKey(i);
+        return this.isVisible ? this.data.getVisibleAsync(i) != null : this.data.getUpdating(i) != null; // Tuinity - avoid copying light data
     }
 
     @Nullable
@@ -37,7 +45,7 @@ public abstract class LightEngineStorageArray<M extends LightEngineStorageArray<
             }
         }
 
-        NibbleArray nibblearray = (NibbleArray) this.a.get(i);
+        NibbleArray nibblearray = (NibbleArray) (this.isVisible ? this.data.getVisibleAsync(i) : this.data.getUpdating(i)); // Tuinity - avoid copying light data
 
         if (nibblearray == null) {
             return null;
@@ -58,11 +66,13 @@ public abstract class LightEngineStorageArray<M extends LightEngineStorageArray<
 
     @Nullable
     public NibbleArray d(long i) {
-        return (NibbleArray) this.a.remove(i);
+        if (this.isVisible) { throw new IllegalStateException("writing to visible data"); } // Tuinity - avoid copying light data
+        return (NibbleArray) this.data.queueRemove(i); // Tuinity - avoid copying light data
     }
 
     public void a(long i, NibbleArray nibblearray) {
-        this.a.put(i, nibblearray);
+        if (this.isVisible) { throw new IllegalStateException("writing to visible data"); } // Tuinity - avoid copying light data
+        this.data.queueUpdate(i, nibblearray); // Tuinity - avoid copying light data
     }
 
     public void c() {
diff --git a/src/main/java/net/minecraft/server/LightEngineStorageBlock.java b/src/main/java/net/minecraft/server/LightEngineStorageBlock.java
index 0f7f4744d9f9e5174fb38ccc72248397a4b064ea..21a15c3b3a861d807ac9256c75e1ff67f33e1dd8 100644
--- a/src/main/java/net/minecraft/server/LightEngineStorageBlock.java
+++ b/src/main/java/net/minecraft/server/LightEngineStorageBlock.java
@@ -5,7 +5,7 @@ import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 public class LightEngineStorageBlock extends LightEngineStorage<LightEngineStorageBlock.a> {
 
     protected LightEngineStorageBlock(ILightAccess ilightaccess) {
-        super(EnumSkyBlock.BLOCK, ilightaccess, new LightEngineStorageBlock.a(new Long2ObjectOpenHashMap()));
+        super(EnumSkyBlock.BLOCK, ilightaccess, new LightEngineStorageBlock.a(new com.tuinity.tuinity.chunk.QueuedChangesMapLong2Object<>(), false)); // Tuinity - avoid copying light data
     }
 
     @Override
@@ -18,13 +18,13 @@ public class LightEngineStorageBlock extends LightEngineStorage<LightEngineStora
 
     public static final class a extends LightEngineStorageArray<LightEngineStorageBlock.a> {
 
-        public a(Long2ObjectOpenHashMap<NibbleArray> long2objectopenhashmap) {
-            super(long2objectopenhashmap);
+        public a(com.tuinity.tuinity.chunk.QueuedChangesMapLong2Object<NibbleArray> long2objectopenhashmap, boolean isVisible) { // Tuinity - avoid copying light data
+            super(long2objectopenhashmap, isVisible); // Tuinity - avoid copying light data
         }
 
         @Override
         public LightEngineStorageBlock.a b() {
-            return new LightEngineStorageBlock.a(this.a.clone());
+            return new a(this.data, true); // Tuinity - avoid copying light data
         }
     }
 }
diff --git a/src/main/java/net/minecraft/server/LightEngineStorageSky.java b/src/main/java/net/minecraft/server/LightEngineStorageSky.java
index 75d9065b32731dc635d9d09c48fb9643172381a9..4669f31b04d98e8369606d9bedf9c0ccc82e4c00 100644
--- a/src/main/java/net/minecraft/server/LightEngineStorageSky.java
+++ b/src/main/java/net/minecraft/server/LightEngineStorageSky.java
@@ -17,7 +17,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
     private volatile boolean p;
 
     protected LightEngineStorageSky(ILightAccess ilightaccess) {
-        super(EnumSkyBlock.SKY, ilightaccess, new LightEngineStorageSky.a(new Long2ObjectOpenHashMap(), new Long2IntOpenHashMap(), Integer.MAX_VALUE));
+        super(EnumSkyBlock.SKY, ilightaccess, new LightEngineStorageSky.a(new com.tuinity.tuinity.chunk.QueuedChangesMapLong2Object<>(), new com.tuinity.tuinity.chunk.QueuedChangesMapLong2Int(), Integer.MAX_VALUE, false)); // Tuinity - avoid copying light data
     }
 
     @Override
@@ -25,7 +25,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
         long j = SectionPosition.e(i);
         int k = SectionPosition.c(j);
         LightEngineStorageSky.a lightenginestoragesky_a = (LightEngineStorageSky.a) this.e;
-        int l = lightenginestoragesky_a.c.get(SectionPosition.f(j));
+        int l = lightenginestoragesky_a.otherData.getVisibleAsync(SectionPosition.f(j)); // Tuinity - avoid copying light data
 
         if (l != lightenginestoragesky_a.b && k < l) {
             NibbleArray nibblearray = this.a(lightenginestoragesky_a, j); // Paper - decompile fix
@@ -54,14 +54,14 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
 
         if (((LightEngineStorageSky.a) this.f).b > j) {
             ((LightEngineStorageSky.a) this.f).b = j;
-            ((LightEngineStorageSky.a) this.f).c.defaultReturnValue(((LightEngineStorageSky.a) this.f).b);
+            ((LightEngineStorageSky.a) this.f).otherData.queueDefaultReturnValue(((LightEngineStorageSky.a) this.f).b); // Tuinity - avoid copying light data
         }
 
         long k = SectionPosition.f(i);
-        int l = ((LightEngineStorageSky.a) this.f).c.get(k);
+        int l = ((LightEngineStorageSky.a) this.f).otherData.getUpdating(k); // Tuinity - avoid copying light data
 
         if (l < j + 1) {
-            ((LightEngineStorageSky.a) this.f).c.put(k, j + 1);
+            ((LightEngineStorageSky.a) this.f).otherData.queueUpdate(k, j + 1); // Tuinity - avoid copying light data
             if (this.o.contains(k)) {
                 this.q(i);
                 if (l > ((LightEngineStorageSky.a) this.f).b) {
@@ -101,7 +101,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
 
         int k = SectionPosition.c(i);
 
-        if (((LightEngineStorageSky.a) this.f).c.get(j) == k + 1) {
+        if (((LightEngineStorageSky.a) this.f).otherData.getUpdating(j) == k + 1) { // Tuinity - avoid copying light data
             long l;
 
             for (l = i; !this.g(l) && this.a(k); l = SectionPosition.a(l, EnumDirection.DOWN)) {
@@ -109,12 +109,12 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
             }
 
             if (this.g(l)) {
-                ((LightEngineStorageSky.a) this.f).c.put(j, k + 1);
+                ((LightEngineStorageSky.a) this.f).otherData.queueUpdate(j, k + 1); // Tuinity - avoid copying light data
                 if (flag) {
                     this.q(l);
                 }
             } else {
-                ((LightEngineStorageSky.a) this.f).c.remove(j);
+                ((LightEngineStorageSky.a) this.f).otherData.queueRemove(j); // Tuinity - avoid copying light data
             }
         }
 
@@ -128,7 +128,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
     protected void b(long i, boolean flag) {
         this.d();
         if (flag && this.o.add(i)) {
-            int j = ((LightEngineStorageSky.a) this.f).c.get(i);
+            int j = ((LightEngineStorageSky.a) this.f).otherData.getUpdating(i); // Tuinity - avoid copying light data
 
             if (j != ((LightEngineStorageSky.a) this.f).b) {
                 long k = SectionPosition.b(SectionPosition.b(i), j - 1, SectionPosition.d(i));
@@ -155,7 +155,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
             return nibblearray;
         } else {
             long j = SectionPosition.a(i, EnumDirection.UP);
-            int k = ((LightEngineStorageSky.a) this.f).c.get(SectionPosition.f(i));
+            int k = ((LightEngineStorageSky.a) this.f).otherData.getUpdating(SectionPosition.f(i)); // Tuinity - avoid copying light data
 
             if (k != ((LightEngineStorageSky.a) this.f).b && SectionPosition.c(j) < k) {
                 NibbleArray nibblearray1;
@@ -298,7 +298,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
             if (!this.o.contains(l)) {
                 return false;
             } else {
-                int i1 = ((LightEngineStorageSky.a) this.f).c.get(l);
+                int i1 = ((LightEngineStorageSky.a) this.f).otherData.getUpdating(l); // Tuinity - avoid copying light data
 
                 return SectionPosition.c(i1) == j + 16;
             }
@@ -307,7 +307,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
 
     protected boolean n(long i) {
         long j = SectionPosition.f(i);
-        int k = ((LightEngineStorageSky.a) this.f).c.get(j);
+        int k = ((LightEngineStorageSky.a) this.f).otherData.getUpdating(j); // Tuinity - avoid copying light data
 
         return k == ((LightEngineStorageSky.a) this.f).b || SectionPosition.c(i) >= k;
     }
@@ -321,18 +321,20 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
     public static final class a extends LightEngineStorageArray<LightEngineStorageSky.a> {
 
         private int b;
-        private final Long2IntOpenHashMap c;
+        private final com.tuinity.tuinity.chunk.QueuedChangesMapLong2Int otherData; // Tuinity - avoid copying light data
 
-        public a(Long2ObjectOpenHashMap<NibbleArray> long2objectopenhashmap, Long2IntOpenHashMap long2intopenhashmap, int i) {
-            super(long2objectopenhashmap);
-            this.c = long2intopenhashmap;
-            long2intopenhashmap.defaultReturnValue(i);
+        // Tuinity start - avoid copying light data
+        public a(com.tuinity.tuinity.chunk.QueuedChangesMapLong2Object<NibbleArray> data, com.tuinity.tuinity.chunk.QueuedChangesMapLong2Int otherData, int i, boolean isVisible) {
+            super(data, isVisible);
+            this.otherData = otherData;
+            // Tuinity end - avoid copying light data
             this.b = i;
         }
 
         @Override
         public LightEngineStorageSky.a b() {
-            return new LightEngineStorageSky.a(this.a.clone(), this.c.clone(), this.b);
+            this.otherData.performUpdatesLockMap(); // Tuinity - avoid copying light data
+            return new LightEngineStorageSky.a(this.data, this.otherData, this.b, true); // Tuinity - avoid copying light data
         }
     }
 }
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index b9d58445205c009d2cbc81db88449f3b40b21377..d1412760dde071f195fdf7070302d27a937d6937 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -500,9 +500,9 @@ public final class MCUtil {
 
             WorldServer world = ((org.bukkit.craftbukkit.CraftWorld)bukkitWorld).getHandle();
             PlayerChunkMap chunkMap = world.getChunkProvider().playerChunkMap;
-            Long2ObjectLinkedOpenHashMap<PlayerChunk> visibleChunks = chunkMap.visibleChunks;
+            // Tuinity - replace chunk map
             ChunkMapDistance chunkMapDistance = chunkMap.getChunkMapDistanceManager();
-            List<PlayerChunk> allChunks = new ArrayList<>(visibleChunks.values());
+            List<PlayerChunk> allChunks = chunkMap.chunkMap.getUpdatingValuesCopy(); // Tuinity - replace chunk map
             List<EntityPlayer> players = world.players;
 
             int fullLoadedChunks = 0;
@@ -525,7 +525,7 @@ public final class MCUtil {
             worldData.addProperty("view-distance", world.spigotConfig.viewDistance);
             worldData.addProperty("keep-spawn-loaded", world.keepSpawnInMemory);
             worldData.addProperty("keep-spawn-loaded-range", world.paperConfig.keepLoadedRange);
-            worldData.addProperty("visible-chunk-count", visibleChunks.size());
+            worldData.addProperty("visible-chunk-count", allChunks.size()); // Tuinity - replace chunk map
             worldData.addProperty("loaded-chunk-count", chunkMap.loadedChunks.size());
             worldData.addProperty("verified-fully-loaded-chunks", fullLoadedChunks);
 
@@ -603,4 +603,28 @@ public final class MCUtil {
         // TODO make sure the constant `33` is correct on future updates. See getChunkAt(int, int, ChunkStatus, boolean)
         return 33 + ChunkStatus.getTicketLevelOffset(status);
     }
+
+    public static <E> boolean hasCommonElement(Set<E> set0, Set<E> set1) {
+        java.util.Iterator<E> iterator;
+        Set<E> target;
+
+        // optimize by iterating over fewest entries possible
+        if (set0.size() <= set1.size()) {
+            target = set1;
+            iterator = set0.iterator();
+        } else {
+            target = set0;
+            iterator = set1.iterator();
+        }
+
+        while (iterator.hasNext()) {
+            E element = iterator.next();
+            if (target.contains(element)) {
+                return true;
+            }
+        }
+
+        return false;
+
+    }
 }
diff --git a/src/main/java/net/minecraft/server/MinecraftKey.java b/src/main/java/net/minecraft/server/MinecraftKey.java
index 2b271d3e509a5450c9136dced3ad4dc4d65af45a..d768ecc03458e849b43e927e7cca285305f086a3 100644
--- a/src/main/java/net/minecraft/server/MinecraftKey.java
+++ b/src/main/java/net/minecraft/server/MinecraftKey.java
@@ -125,15 +125,29 @@ public class MinecraftKey implements Comparable<MinecraftKey> {
     }
 
     private static boolean c(String s) {
-        return s.chars().allMatch((i) -> {
-            return i == 95 || i == 45 || i >= 97 && i <= 122 || i >= 48 && i <= 57 || i == 47 || i == 46;
-        });
+        // Tuinity start - remove streams
+        for (int index = 0, len = s.length(); index < len; ++index) {
+            int i = (int)s.charAt(index);
+            boolean condition = i == 95 || i == 45 || i >= 97 && i <= 122 || i >= 48 && i <= 57 || i == 47 || i == 46; // this is copied from the replaced code.
+            if (!condition) {
+                return false;
+            }
+        }
+        // Tuinity end - remove streams
+        return true;
     }
 
     private static boolean d(String s) {
-        return s.chars().allMatch((i) -> {
-            return i == 95 || i == 45 || i >= 97 && i <= 122 || i >= 48 && i <= 57 || i == 46;
-        });
+        // Tuinity start - remove streams
+        for (int index = 0, len = s.length(); index < len; ++index) {
+            int i = (int)s.charAt(index);
+            boolean condition = i == 95 || i == 45 || i >= 97 && i <= 122 || i >= 48 && i <= 57 || i == 46; // this is copied from the replaced code.
+            if (!condition) {
+                return false;
+            }
+        }
+        return true;
+        // Tuinity end - remove streams
     }
 
     public static class a implements JsonDeserializer<MinecraftKey>, JsonSerializer<MinecraftKey> {
diff --git a/src/main/java/net/minecraft/server/NBTTagCompound.java b/src/main/java/net/minecraft/server/NBTTagCompound.java
index 98deaba12ceb25f59d1b56420fb544a64b417ddd..4b9ae130105d2dc28c2c87ae2e201d4e8660c270 100644
--- a/src/main/java/net/minecraft/server/NBTTagCompound.java
+++ b/src/main/java/net/minecraft/server/NBTTagCompound.java
@@ -31,7 +31,7 @@ public class NBTTagCompound implements NBTBase {
             if (i > 512) {
                 throw new RuntimeException("Tried to read NBT tag with too high complexity, depth > 512");
             } else {
-                HashMap hashmap = Maps.newHashMap();
+                it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap<String, NBTBase> hashmap = new it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap<>(8, 0.8f); // Tuinity - reduce memory footprint of NBTTagCompound
 
                 byte b0;
 
@@ -67,7 +67,7 @@ public class NBTTagCompound implements NBTBase {
     }
 
     public NBTTagCompound() {
-        this(Maps.newHashMap());
+        this(new it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap<>(8, 0.8f)); // Tuinity - reduce memory footprint of NBTTagCompound
     }
 
     @Override
@@ -402,9 +402,17 @@ public class NBTTagCompound implements NBTBase {
 
     @Override
     public NBTTagCompound clone() {
-        Map<String, NBTBase> map = Maps.newHashMap(Maps.transformValues(this.map, NBTBase::clone));
+        // Tuinity start - reduce memory footprint of NBTTagCompound
+        it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap<String, NBTBase> ret = new it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap<>(this.map.size(), 0.8f);
 
-        return new NBTTagCompound(map);
+        Iterator<Map.Entry<String, NBTBase>> iterator = (this.map instanceof it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap) ? ((it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap)this.map).object2ObjectEntrySet().fastIterator() : this.map.entrySet().iterator();
+        while (iterator.hasNext()) {
+            Map.Entry<String, NBTBase> entry = iterator.next();
+            ret.put(entry.getKey(), entry.getValue().clone());
+        }
+
+        return new NBTTagCompound(ret);
+        // Tuinity end - reduce memory footprint of NBTTagCompound
     }
 
     public boolean equals(Object object) {
diff --git a/src/main/java/net/minecraft/server/PairedQueue.java b/src/main/java/net/minecraft/server/PairedQueue.java
index 85bb22e4b7376b676139048f2d55684e27a54055..1e618446a4cf08c86296aadf356d0363e047e12d 100644
--- a/src/main/java/net/minecraft/server/PairedQueue.java
+++ b/src/main/java/net/minecraft/server/PairedQueue.java
@@ -20,32 +20,30 @@ public interface PairedQueue<T, F> {
 
     public static final class a implements PairedQueue<PairedQueue.b, Runnable> {
 
-        private final List<Queue<Runnable>> a;
+        private final List<Queue<Runnable>> a; private final List<Queue<Runnable>> getQueues() { return this.a; } // Tuinity - OBFHELPER
 
         public a(int i) {
-            this.a = (List) IntStream.range(0, i).mapToObj((j) -> {
-                return Queues.newConcurrentLinkedQueue();
-            }).collect(Collectors.toList());
+            // Tuinity start - reduce streams
+            this.a = new java.util.ArrayList<>(i); // queues
+            for (int j = 0; j < i; ++j) {
+                this.getQueues().add(new ca.spottedleaf.concurrentutil.queue.MultiThreadedQueue<>()); // use MT queue
+            }
+            // Tuinity end - reduce streams
         }
 
         @Nullable
         @Override
         public Runnable a() {
-            Iterator iterator = this.a.iterator();
-
-            Runnable runnable;
-
-            do {
-                if (!iterator.hasNext()) {
-                    return null;
+            // Tuinity start - reduce iterator creation
+            for (int i = 0, len = this.getQueues().size(); i < len; ++i) {
+                Queue<Runnable> queue = this.getQueues().get(i);
+                Runnable ret = queue.poll();
+                if (ret != null) {
+                    return ret;
                 }
-
-                Queue<Runnable> queue = (Queue) iterator.next();
-
-                runnable = (Runnable) queue.poll();
-            } while (runnable == null);
-
-            return runnable;
+            }
+            return null;
+            // Tuinity end - reduce iterator creation
         }
 
         public boolean a(PairedQueue.b pairedqueue_b) {
@@ -57,7 +55,15 @@ public interface PairedQueue<T, F> {
 
         @Override
         public boolean b() {
-            return this.a.stream().allMatch(Collection::isEmpty);
+            // Tuinity start - reduce streams
+            for (int i = 0, len = this.getQueues().size(); i < len; ++i) {
+                Queue<Runnable> queue = this.getQueues().get(i);
+                if (!queue.isEmpty()) {
+                    return false;
+                }
+            }
+            return true;
+            // Tuinity end - reduce streams
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/PathfinderGoal.java b/src/main/java/net/minecraft/server/PathfinderGoal.java
index bdb90a346639db37d3c72359c28b72d021d1b389..738c510706089f46551f1884a0accc147c07836c 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoal.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoal.java
@@ -1,10 +1,11 @@
 package net.minecraft.server;
 
+import com.tuinity.tuinity.util.OptimizedSmallEnumSet; // Tuinity
 import java.util.EnumSet;
 
 public abstract class PathfinderGoal {
 
-    private final EnumSet<PathfinderGoal.Type> a = EnumSet.noneOf(PathfinderGoal.Type.class);
+    private final OptimizedSmallEnumSet<Type> goalTypes = new OptimizedSmallEnumSet<>(PathfinderGoal.Type.class); // Tuinity - reduce garbage on heap
 
     public PathfinderGoal() {}
 
@@ -28,16 +29,20 @@ public abstract class PathfinderGoal {
     public void e() {}
 
     public void a(EnumSet<PathfinderGoal.Type> enumset) {
-        this.a.clear();
-        this.a.addAll(enumset);
+        // Tuinity start - reduce garbage on heap
+        this.goalTypes.clear();
+        this.goalTypes.addAllUnchecked(enumset);
+        // Tuinity end - reduce garbage on heap
     }
 
     public String toString() {
         return this.getClass().getSimpleName();
     }
 
-    public EnumSet<PathfinderGoal.Type> i() {
-        return this.a;
+    // Tuinity start - reduce garbage on heap
+    public com.tuinity.tuinity.util.OptimizedSmallEnumSet<PathfinderGoal.Type> getGoalTypes() {
+        return this.goalTypes;
+        // Tuinity end - reduce garbage on heap
     }
 
     public static enum Type {
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalSelector.java b/src/main/java/net/minecraft/server/PathfinderGoalSelector.java
index 935136771e776fe498f608a159a41393340adc4e..782edcb63b8e7d181acfc2998ddaf8e7120fa7f5 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalSelector.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalSelector.java
@@ -1,8 +1,10 @@
 package net.minecraft.server;
 
+import com.tuinity.tuinity.util.OptimizedSmallEnumSet;
 import com.google.common.collect.Sets;
 import java.util.EnumMap;
 import java.util.EnumSet;
+import java.util.Iterator; // Tuinity
 import java.util.Map;
 import java.util.Set;
 import java.util.stream.Stream;
@@ -26,7 +28,7 @@ public class PathfinderGoalSelector {
     private final Map<PathfinderGoal.Type, PathfinderGoalWrapped> c = new EnumMap(PathfinderGoal.Type.class);
     private final Set<PathfinderGoalWrapped> d = Sets.newLinkedHashSet();private Set<PathfinderGoalWrapped> getTasks() { return d; }// Paper - OBFHELPER
     private final GameProfilerFiller e;
-    private final EnumSet<PathfinderGoal.Type> f = EnumSet.noneOf(PathfinderGoal.Type.class);
+    private final OptimizedSmallEnumSet<PathfinderGoal.Type> goalTypes = new OptimizedSmallEnumSet<>(PathfinderGoal.Type.class); // Tuinity - reduce garbage on heap
     private int g = 3;private int getTickRate() { return g; } // Paper - OBFHELPER
     private int curRate;private int getCurRate() { return curRate; } private void incRate() { this.curRate++; } // Paper TODO
 
@@ -58,33 +60,38 @@ public class PathfinderGoalSelector {
     // Paper end
 
     public void a(PathfinderGoal pathfindergoal) {
-        this.d.stream().filter((pathfindergoalwrapped) -> {
-            return pathfindergoalwrapped.j() == pathfindergoal;
-        }).filter(PathfinderGoalWrapped::g).forEach(PathfinderGoalWrapped::d);
-        this.d.removeIf((pathfindergoalwrapped) -> {
-            return pathfindergoalwrapped.j() == pathfindergoal;
-        });
+        // Tuinity start - remove streams
+        for (Iterator<PathfinderGoalWrapped> iterator = this.d.iterator(); iterator.hasNext();) {
+            PathfinderGoalWrapped goalWrapped = iterator.next();
+            if (goalWrapped.j() != pathfindergoal) {
+                continue;
+            }
+            if (goalWrapped.g()) {
+                goalWrapped.d();
+            }
+            iterator.remove();
+        }
+        // Tuinity end
     }
 
+    private static final PathfinderGoal.Type[] PATHFINDER_GOAL_TYPES = PathfinderGoal.Type.values();
+
     public void doTick() {
         this.e.enter("goalCleanup");
-        this.c().filter((pathfindergoalwrapped) -> {
-            boolean flag;
-
-            if (pathfindergoalwrapped.g()) {
-                Stream stream = pathfindergoalwrapped.i().stream();
-                EnumSet enumset = this.f;
+        // Tuinity start - remove streams
+        for (Iterator<PathfinderGoalWrapped> iterator = this.d.iterator(); iterator.hasNext();) {
+            PathfinderGoalWrapped wrappedGoal = iterator.next();
+            if (!wrappedGoal.g()) {
+                continue;
+            }
 
-                this.f.getClass();
-                if (!stream.anyMatch(enumset::contains) && pathfindergoalwrapped.b()) {
-                    flag = false;
-                    return flag;
-                }
+            if (!this.goalTypes.hasCommonElements(wrappedGoal.getGoalTypes()) && wrappedGoal.b()) {
+                continue;
             }
 
-            flag = true;
-            return flag;
-        }).forEach(PathfinderGoal::d);
+            wrappedGoal.d();
+        }
+        // Tuinity end
         this.c.forEach((pathfindergoal_type, pathfindergoalwrapped) -> {
             if (!pathfindergoalwrapped.g()) {
                 this.c.remove(pathfindergoal_type);
@@ -93,30 +100,58 @@ public class PathfinderGoalSelector {
         });
         this.e.exit();
         this.e.enter("goalUpdate");
-        this.d.stream().filter((pathfindergoalwrapped) -> {
-            return !pathfindergoalwrapped.g();
-        }).filter((pathfindergoalwrapped) -> {
-            Stream stream = pathfindergoalwrapped.i().stream();
-            EnumSet enumset = this.f;
-
-            this.f.getClass();
-            return stream.noneMatch(enumset::contains);
-        }).filter((pathfindergoalwrapped) -> {
-            return pathfindergoalwrapped.i().stream().allMatch((pathfindergoal_type) -> {
-                return ((PathfinderGoalWrapped) this.c.getOrDefault(pathfindergoal_type, PathfinderGoalSelector.b)).a(pathfindergoalwrapped);
-            });
-        }).filter(PathfinderGoalWrapped::a).forEach((pathfindergoalwrapped) -> {
-            pathfindergoalwrapped.i().forEach((pathfindergoal_type) -> {
-                PathfinderGoalWrapped pathfindergoalwrapped1 = (PathfinderGoalWrapped) this.c.getOrDefault(pathfindergoal_type, PathfinderGoalSelector.b);
-
-                pathfindergoalwrapped1.d();
-                this.c.put(pathfindergoal_type, pathfindergoalwrapped);
-            });
-            pathfindergoalwrapped.c();
-        });
+        // Tuinity start - remove streams
+        goal_update_loop: for (Iterator<PathfinderGoalWrapped> iterator = this.d.iterator(); iterator.hasNext();) {
+            PathfinderGoalWrapped wrappedGoal = iterator.next();
+            if (wrappedGoal.g()) {
+                continue;
+            }
+
+            OptimizedSmallEnumSet<PathfinderGoal.Type> wrappedGoalSet = wrappedGoal.getGoalTypes();
+
+            if (this.goalTypes.hasCommonElements(wrappedGoalSet)) {
+                continue;
+            }
+
+            long iterator1 = wrappedGoalSet.getBackingSet();
+            int wrappedGoalSize = wrappedGoalSet.size();
+            for (int i = 0; i < wrappedGoalSize; ++i) {
+                PathfinderGoal.Type type = PATHFINDER_GOAL_TYPES[Long.numberOfTrailingZeros(iterator1)];
+                iterator1 ^= ca.spottedleaf.concurrentutil.util.IntegerUtil.getTrailingBit(iterator1);
+                PathfinderGoalWrapped wrapped = this.c.getOrDefault(type, PathfinderGoalSelector.b);
+                if (!wrapped.a(wrappedGoal)) {
+                    continue goal_update_loop;
+                }
+            }
+
+            if (!wrappedGoal.a()) {
+                continue;
+            }
+
+            iterator1 = wrappedGoalSet.getBackingSet();
+            wrappedGoalSize = wrappedGoalSet.size();
+            for (int i = 0; i < wrappedGoalSize; ++i) {
+                PathfinderGoal.Type type = PATHFINDER_GOAL_TYPES[Long.numberOfTrailingZeros(iterator1)];
+                iterator1 ^= ca.spottedleaf.concurrentutil.util.IntegerUtil.getTrailingBit(iterator1);
+                PathfinderGoalWrapped wrapped = this.c.getOrDefault(type, PathfinderGoalSelector.b);
+
+                wrapped.d();
+                this.c.put(type, wrappedGoal);
+            }
+
+            wrappedGoal.c();
+        }
+        // Tuinity end
         this.e.exit();
         this.e.enter("goalTick");
-        this.c().forEach(PathfinderGoalWrapped::e);
+        // Tuinity start - remove streams
+        for (Iterator<PathfinderGoalWrapped> iterator = this.d.iterator(); iterator.hasNext();) {
+            PathfinderGoalWrapped wrappedGoal = iterator.next();
+            if (wrappedGoal.g()) {
+                wrappedGoal.e();
+            }
+        }
+        // Tuinity end
         this.e.exit();
     }
 
@@ -125,11 +160,11 @@ public class PathfinderGoalSelector {
     }
 
     public void a(PathfinderGoal.Type pathfindergoal_type) {
-        this.f.add(pathfindergoal_type);
+        this.goalTypes.addUnchecked(pathfindergoal_type); // Tuinity - reduce streams
     }
 
     public void b(PathfinderGoal.Type pathfindergoal_type) {
-        this.f.remove(pathfindergoal_type);
+        this.goalTypes.removeUnchecked(pathfindergoal_type); // Tuinity - reduce streams
     }
 
     public void a(PathfinderGoal.Type pathfindergoal_type, boolean flag) {
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalWrapped.java b/src/main/java/net/minecraft/server/PathfinderGoalWrapped.java
index 29657fed75184aee0c89e56f5e642a5d68eda444..71919adc0d2a9110fe5c84976f6153970684ac35 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalWrapped.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalWrapped.java
@@ -60,8 +60,10 @@ public class PathfinderGoalWrapped extends PathfinderGoal {
     }
 
     @Override
-    public EnumSet<PathfinderGoal.Type> i() {
-        return this.a.i();
+    // Tuinity start - reduce garbage on heap
+    public com.tuinity.tuinity.util.OptimizedSmallEnumSet<PathfinderGoal.Type> getGoalTypes() {
+        return this.a.getGoalTypes();
+        // Tuinity end - reduce garbage on heap
     }
 
     public boolean isRunning() { return this.g(); } // Paper - OBFHELPER
diff --git a/src/main/java/net/minecraft/server/PathfinderNormal.java b/src/main/java/net/minecraft/server/PathfinderNormal.java
index 4240ca81cb6debecc54dcf9a550e9d916dfa8f9f..69fd3cc8ec4680709f26bbe7dd9942d79173b401 100644
--- a/src/main/java/net/minecraft/server/PathfinderNormal.java
+++ b/src/main/java/net/minecraft/server/PathfinderNormal.java
@@ -443,8 +443,10 @@ public class PathfinderNormal extends PathfinderAbstract {
         return pathtype;
     }
 
+    private static final BlockPosition.MutableBlockPosition PATH_TYPE_BLOCKPOSITION = new BlockPosition.MutableBlockPosition(); // Tuinity - this shows to be a high allocator
+
     protected static PathType c(IBlockAccess iblockaccess, int i, int j, int k) {
-        BlockPosition blockposition = new BlockPosition(i, j, k);
+        BlockPosition blockposition = PATH_TYPE_BLOCKPOSITION.setValues(i, j, k); // Tuinity - this shows to be a high allocator
         IBlockData iblockdata = iblockaccess.getTypeIfLoaded(blockposition); // Paper
         if (iblockdata == null) return PathType.BLOCKED; // Paper
         Block block = iblockdata.getBlock();
diff --git a/src/main/java/net/minecraft/server/PlayerChunk.java b/src/main/java/net/minecraft/server/PlayerChunk.java
index 9f8818c2d4ca0064ab098cc6e0de170dab90b166..f9100a27177d4cd23ce7f96b3329c9ad6ff8937f 100644
--- a/src/main/java/net/minecraft/server/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/PlayerChunk.java
@@ -505,6 +505,14 @@ public class PlayerChunk {
                     PlayerChunk.this.isEntityTickingReady = true;
 
 
+                    // Tuinity start - stop throwing garbage on the heap
+                    ChunkProviderServer chunkProvider = PlayerChunk.this.chunkMap.world.getChunkProvider();
+                    if (chunkProvider.isTickingChunks) {
+                        chunkProvider.pendingEntityTickingChunkChanges.put(entityTickingChunk, true);
+                    } else {
+                        chunkProvider.entityTickingChunks.add(entityTickingChunk);
+                    }
+                    // Tuinity end - stop throwing garbage on the heap
 
 
                 }
@@ -515,6 +523,18 @@ public class PlayerChunk {
 
         if (flag6 && !flag7) {
             this.entityTickingFuture.complete(PlayerChunk.UNLOADED_CHUNK); this.isEntityTickingReady = false; // Paper - cache chunk ticking stage
+
+            // Tuinity start - stop throwing garbage on the heap
+            ChunkProviderServer chunkProvider = PlayerChunk.this.chunkMap.world.getChunkProvider();
+            Chunk chunk = this.getFullChunkIfCached();
+            if (chunk != null) {
+                if (chunkProvider.isTickingChunks) {
+                    chunkProvider.pendingEntityTickingChunkChanges.put(chunk, false);
+                } else {
+                    chunkProvider.entityTickingChunks.remove(chunk);
+                }
+            }
+            // Tuinity end - stop throwing garbage on the heap
             this.entityTickingFuture = PlayerChunk.UNLOADED_CHUNK_FUTURE;
         }
 
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 1a75f5d30c0cb034506a588c31e8d52700b0c4c9..ec13a1c157bdb2561ee6f1ff7d86f816cda0e953 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -55,8 +55,9 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     private static final Logger LOGGER = LogManager.getLogger();
     public static final int GOLDEN_TICKET = 33 + ChunkStatus.b();
-    public final Long2ObjectLinkedOpenHashMap<PlayerChunk> updatingChunks = new Long2ObjectLinkedOpenHashMap();
-    public volatile Long2ObjectLinkedOpenHashMap<PlayerChunk> visibleChunks;
+    //public final Long2ObjectLinkedOpenHashMap<PlayerChunk> updatingChunks = new Long2ObjectLinkedOpenHashMap(); // Tuinity - replace chunk map
+    //public volatile Long2ObjectLinkedOpenHashMap<PlayerChunk> visibleChunks; // Tuinity - replace chunk map
+    public final com.tuinity.tuinity.chunk.QueuedChangesMapLong2Object<PlayerChunk> chunkMap = new com.tuinity.tuinity.chunk.QueuedChangesMapLong2Object<>(8192, 0.7f); // Tuinity - replace chunk map
     private final Long2ObjectLinkedOpenHashMap<PlayerChunk> pendingUnload;
     final LongSet loadedChunks; // Paper - private -> package
     public final WorldServer world;
@@ -193,7 +194,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     public PlayerChunkMap(WorldServer worldserver, File file, DataFixer datafixer, DefinedStructureManager definedstructuremanager, Executor executor, IAsyncTaskHandler<Runnable> iasynctaskhandler, ILightAccess ilightaccess, ChunkGenerator<?> chunkgenerator, WorldLoadListener worldloadlistener, Supplier<WorldPersistentData> supplier, int i) {
         super(new File(worldserver.getWorldProvider().getDimensionManager().a(file), "region"), datafixer);
-        this.visibleChunks = this.updatingChunks.clone();
+        //this.visibleChunks = this.updatingChunks.clone(); // Tuinity - replace chunk map
         this.pendingUnload = new Long2ObjectLinkedOpenHashMap();
         this.loadedChunks = new LongOpenHashSet();
         this.unloadQueue = new LongOpenHashSet();
@@ -288,8 +289,13 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     private static int a(ChunkCoordIntPair chunkcoordintpair, int i, int j) {
-        int k = chunkcoordintpair.x - i;
-        int l = chunkcoordintpair.z - j;
+        // Tuinity start - remove ChunkCoordIntPair allocation
+        return getSquareRadiusDistance(chunkcoordintpair.x, chunkcoordintpair.z, i, j);
+    }
+    private static int getSquareRadiusDistance(int chunkX0, int chunkZ0, int i, int j) {
+        int k = chunkX0 - i;
+        int l = chunkZ0 - j;
+        // Tuinity end
 
         return Math.max(Math.abs(k), Math.abs(l));
     }
@@ -300,12 +306,17 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     @Nullable
     protected PlayerChunk getUpdatingChunk(long i) {
-        return (PlayerChunk) this.updatingChunks.get(i);
+        return (PlayerChunk) this.chunkMap.getUpdating(i); // Tuinity - replace chunk map
     }
 
     @Nullable
     public PlayerChunk getVisibleChunk(long i) { // Paper - protected -> public
-        return (PlayerChunk) this.visibleChunks.get(i);
+        // Tuinity start - replace chunk map
+        if (MinecraftServer.getServer().serverThread == Thread.currentThread()) {
+            return this.chunkMap.getVisible(i);
+        }
+        return (PlayerChunk) this.chunkMap.getVisibleAsync(i);
+        // Tuinity end - replace chunk map
     }
 
     protected IntSupplier c(long i) {
@@ -407,7 +418,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                     playerchunk = new PlayerChunk(new ChunkCoordIntPair(i), j, this.lightEngine, this.p, this);
                 }
 
-                this.updatingChunks.put(i, playerchunk);
+                this.chunkMap.queueUpdate(i, playerchunk); // Tuinity - replace chunk map
                 this.updatingChunksModified = true;
             }
 
@@ -487,7 +498,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     protected void save(boolean flag) {
         if (flag) {
-            List<PlayerChunk> list = (List) this.visibleChunks.values().stream().filter(PlayerChunk::hasBeenLoaded).peek(PlayerChunk::m).collect(Collectors.toList());
+            List<PlayerChunk> list = (List) this.chunkMap.getVisibleValues().stream().filter(PlayerChunk::hasBeenLoaded).peek(PlayerChunk::m).collect(Collectors.toList()); // Tuinity - replace chunk map
             MutableBoolean mutableboolean = new MutableBoolean();
 
             do {
@@ -515,7 +526,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 //            this.i(); // Paper - nuke IOWorker
             PlayerChunkMap.LOGGER.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", this.w.getName());
         } else {
-            this.visibleChunks.values().stream().filter(PlayerChunk::hasBeenLoaded).forEach((playerchunk) -> {
+            this.chunkMap.getVisibleValues().stream().filter(PlayerChunk::hasBeenLoaded).forEach((playerchunk) -> { // Tuinity - replace chunk map
                 IChunkAccess ichunkaccess = (IChunkAccess) playerchunk.getChunkSave().getNow(null); // CraftBukkit - decompile error
 
                 if (ichunkaccess instanceof ProtoChunkExtension || ichunkaccess instanceof Chunk) {
@@ -557,7 +568,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         while (longiterator.hasNext()) { // Spigot
             long j = longiterator.nextLong();
             longiterator.remove(); // Spigot
-            PlayerChunk playerchunk = (PlayerChunk) this.updatingChunks.remove(j);
+            PlayerChunk playerchunk = (PlayerChunk) this.chunkMap.queueRemove(j); // Tuinity - replace chunk map
 
             if (playerchunk != null) {
                 this.pendingUnload.put(j, playerchunk);
@@ -685,7 +696,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         if (!this.updatingChunksModified) {
             return false;
         } else {
-            this.visibleChunks = this.updatingChunks.clone();
+            this.chunkMap.performUpdates(); // Tuinity - replace chunk map
             this.updatingChunksModified = false;
             return true;
         }
@@ -1095,7 +1106,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
             this.viewDistance = j;
             this.chunkDistanceManager.a(this.viewDistance);
-            ObjectIterator objectiterator = this.updatingChunks.values().iterator();
+            Iterator objectiterator = this.chunkMap.getUpdatingValues().iterator(); // Tuinity - replace chunk map
 
             while (objectiterator.hasNext()) {
                 PlayerChunk playerchunk = (PlayerChunk) objectiterator.next();
@@ -1115,9 +1126,14 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     protected void sendChunk(EntityPlayer entityplayer, ChunkCoordIntPair chunkcoordintpair, Packet<?>[] apacket, boolean flag, boolean flag1) {
+        // Tuinity start - remove ChunkCoordIntPair allocation, use two ints instead of ChunkCoordIntPair
+        this.sendChunk(entityplayer, chunkcoordintpair.x, chunkcoordintpair.z, apacket, flag, flag1);
+    }
+    protected void sendChunk(EntityPlayer entityplayer, int chunkX, int chunkZ, Packet<?>[] apacket, boolean flag, boolean flag1) {
+        // Tuinity end
         if (entityplayer.world == this.world) {
             if (flag1 && !flag) {
-                PlayerChunk playerchunk = this.getVisibleChunk(chunkcoordintpair.pair());
+                PlayerChunk playerchunk = this.getVisibleChunk(ChunkCoordIntPair.pair(chunkX, chunkZ)); // Tuinity - remove ChunkCoordIntPair allocation
 
                 if (playerchunk != null) {
                     Chunk chunk = playerchunk.getChunk();
@@ -1126,19 +1142,19 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                         this.a(entityplayer, apacket, chunk);
                     }
 
-                    PacketDebug.a(this.world, chunkcoordintpair);
+                    //PacketDebug.a(this.world, chunkcoordintpair); // Tuinity - remove ChunkCoordIntPair allocation (this function is a no-op)
                 }
             }
 
             if (!flag1 && flag) {
-                entityplayer.a(chunkcoordintpair);
+                entityplayer.sendChunkUnload(chunkX, chunkZ); // Tuinity - remove ChunkCoordIntPair allocation
             }
 
         }
     }
 
     public int d() {
-        return this.visibleChunks.size();
+        return this.chunkMap.getVisibleSizeAsync(); // Tuinity - replace chunk map
     }
 
     protected PlayerChunkMap.a e() {
@@ -1146,12 +1162,12 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     protected Iterable<PlayerChunk> f() {
-        return Iterables.unmodifiableIterable(this.visibleChunks.values());
+        return Iterables.unmodifiableIterable(this.chunkMap.getUpdatingValuesCopy()); // Tuinity - replace chunk map
     }
 
     void a(Writer writer) throws IOException {
         CSVWriter csvwriter = CSVWriter.a().a("x").a("z").a("level").a("in_memory").a("status").a("full_status").a("accessible_ready").a("ticking_ready").a("entity_ticking_ready").a("ticket").a("spawning").a("entity_count").a("block_entity_count").a(writer);
-        ObjectBidirectionalIterator objectbidirectionaliterator = this.visibleChunks.long2ObjectEntrySet().iterator();
+        ObjectBidirectionalIterator objectbidirectionaliterator = this.chunkMap.getVisibleMap().long2ObjectEntrySet().iterator(); // Tuinity - replace chunk map
 
         while (objectbidirectionaliterator.hasNext()) {
             Entry<PlayerChunk> entry = (Entry) objectbidirectionaliterator.next();
@@ -1391,11 +1407,13 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             }
         }
 
+        Packet[] cachedPackets = new Packet[2]; // Tuinity
         for (int k = i - this.viewDistance; k <= i + this.viewDistance; ++k) {
             for (int l = j - this.viewDistance; l <= j + this.viewDistance; ++l) {
-                ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k, l);
-
-                this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], !flag, flag);
+                // Tuinity start - remove excess object creation (ChunkCoordIntPair and Packet[])
+                this.sendChunk(entityplayer, k, l, cachedPackets, !flag, flag);
+                java.util.Arrays.fill(cachedPackets, null);
+                // Tuinity end
             }
         }
 
@@ -1478,35 +1496,47 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             int i2 = Math.max(i, i1) + this.viewDistance;
             int j2 = Math.max(j, j1) + this.viewDistance;
 
+            Packet[] cachedPackets = new Packet[2]; // Tuinity
+
             for (int k2 = k1; k2 <= i2; ++k2) {
                 for (int l2 = l1; l2 <= j2; ++l2) {
-                    ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k2, l2);
-                    boolean flag3 = a(chunkcoordintpair, i1, j1) <= this.viewDistance;
-                    boolean flag4 = a(chunkcoordintpair, i, j) <= this.viewDistance;
+                    // Tuinity start - remove ChunkCoordIntPair allocation
+                    boolean flag3 = getSquareRadiusDistance(k2, l2, i1, j1) <= this.viewDistance;
+                    boolean flag4 = getSquareRadiusDistance(k2, l2, i, j) <= this.viewDistance;
 
-                    this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], flag3, flag4);
+                    this.sendChunk(entityplayer, k2, l2, cachedPackets, flag3, flag4);
+                    java.util.Arrays.fill(cachedPackets, null);
+                    // Tuinity end
                 }
             }
         } else {
-            ChunkCoordIntPair chunkcoordintpair1;
+            //ChunkCoordIntPair chunkcoordintpair1; // Tuinity - we don't set, so compile fail on further uses
             boolean flag5;
             boolean flag6;
 
+            Packet[] cachedPackets = new Packet[2]; // Tuinity
+
             for (k1 = i1 - this.viewDistance; k1 <= i1 + this.viewDistance; ++k1) {
                 for (l1 = j1 - this.viewDistance; l1 <= j1 + this.viewDistance; ++l1) {
-                    chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
+                    // Tuinity - remove ChunkCoordIntPair allocation
                     flag5 = true;
                     flag6 = false;
-                    this.sendChunk(entityplayer, chunkcoordintpair1, new Packet[2], true, false);
+                    // Tuinity start - remove ChunkCoordIntPair allocation
+                    this.sendChunk(entityplayer, k1, l1, cachedPackets, true, false);
+                    java.util.Arrays.fill(cachedPackets, null);
+                    // Tuinity end
                 }
             }
 
             for (k1 = i - this.viewDistance; k1 <= i + this.viewDistance; ++k1) {
                 for (l1 = j - this.viewDistance; l1 <= j + this.viewDistance; ++l1) {
-                    chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
+                    // Tuinity - remove ChunkCoordIntPair allocation
                     flag5 = false;
                     flag6 = true;
-                    this.sendChunk(entityplayer, chunkcoordintpair1, new Packet[2], false, true);
+                    // Tuinity start - remove ChunkCoordIntPair allocation
+                    this.sendChunk(entityplayer, k1, l1, cachedPackets, false, true);
+                    java.util.Arrays.fill(cachedPackets, null);
+                    // Tuinity end
                 }
             }
         }
@@ -1791,10 +1821,13 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         public void updatePlayer(EntityPlayer entityplayer) {
             org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot
             if (entityplayer != this.tracker) {
-                Vec3D vec3d = entityplayer.getPositionVector().d(this.tracker.getPositionVector()); // MC-155077, SPIGOT-5113
+                // Tuinity start - remove allocation of Vec3d here
+                double vec3d_dx = entityplayer.locX() - this.tracker.locX();
+                double vec3d_dy = entityplayer.locY() - this.tracker.locY();
+                double vec3d_dz = entityplayer.locZ() - this.tracker.locZ();
+                // Tuinity end - remove allocation of Vec3d here
                 int i = Math.min(this.b(), (PlayerChunkMap.this.viewDistance - 1) * 16);
-                boolean flag = vec3d.x >= (double) (-i) && vec3d.x <= (double) i && vec3d.z >= (double) (-i) && vec3d.z <= (double) i && this.tracker.a(entityplayer);
-
+                boolean flag = vec3d_dx >= (double) (-i) && vec3d_dx <= (double) i && vec3d_dz >= (double) (-i) && vec3d_dz <= (double) i && this.tracker.a(entityplayer); // Tuinity start - remove allocation of Vec3d here
                 if (flag) {
                     boolean flag1 = this.tracker.attachedToPlayer;
 
diff --git a/src/main/java/net/minecraft/server/PlayerInventory.java b/src/main/java/net/minecraft/server/PlayerInventory.java
index d103cfaace4f42aaad677103f4eef578490699da..1b8cb3fc61e83d52625d221495173c301b0ce52a 100644
--- a/src/main/java/net/minecraft/server/PlayerInventory.java
+++ b/src/main/java/net/minecraft/server/PlayerInventory.java
@@ -559,8 +559,10 @@ public class PlayerInventory implements IInventory, INamableTileEntity {
 
         NonNullList nonnulllist;
 
-        for (Iterator iterator = this.f.iterator(); iterator.hasNext(); i -= nonnulllist.size()) {
-            nonnulllist = (NonNullList) iterator.next();
+        // Tuinity start - reduce iterator creation
+        for (int index = 0, len = this.f.size(); index < len; ++index, i -= nonnulllist.size()) {
+            nonnulllist = this.f.get(index);
+            // Tuinity end - reduce iterator creation
             if (i < nonnulllist.size()) {
                 list = nonnulllist;
                 break;
diff --git a/src/main/java/net/minecraft/server/ProtoChunk.java b/src/main/java/net/minecraft/server/ProtoChunk.java
index f376e210687fb30fbe8e093c397b710d3bd07ecc..5a883aac14052f6637acbf4cf96236936fee98c3 100644
--- a/src/main/java/net/minecraft/server/ProtoChunk.java
+++ b/src/main/java/net/minecraft/server/ProtoChunk.java
@@ -180,14 +180,11 @@ public class ProtoChunk implements IChunkAccess {
                     lightengine.a(blockposition);
                 }
 
-                EnumSet<HeightMap.Type> enumset = this.getChunkStatus().h();
+                HeightMap.Type[] enumset = this.getChunkStatus().heightMaps; // Tuinity - reduce iterator creation
                 EnumSet<HeightMap.Type> enumset1 = null;
-                Iterator iterator = enumset.iterator();
+                // Tuinity - reduce iterator creation
 
-                HeightMap.Type heightmap_type;
-
-                while (iterator.hasNext()) {
-                    heightmap_type = (HeightMap.Type) iterator.next();
+                for (HeightMap.Type heightmap_type : enumset) { // Tuinity - reduce iterator creation
                     HeightMap heightmap = (HeightMap) this.f.get(heightmap_type);
 
                     if (heightmap == null) {
@@ -203,10 +200,9 @@ public class ProtoChunk implements IChunkAccess {
                     HeightMap.a(this, enumset1);
                 }
 
-                iterator = enumset.iterator();
-
-                while (iterator.hasNext()) {
-                    heightmap_type = (HeightMap.Type) iterator.next();
+                // Tuinity start - reduce iterator creation
+                for (HeightMap.Type heightmap_type : enumset) {
+                    // Tuinity end
                     ((HeightMap) this.f.get(heightmap_type)).a(i & 15, j, k & 15, iblockdata);
                 }
 
diff --git a/src/main/java/net/minecraft/server/VoxelShapeArray.java b/src/main/java/net/minecraft/server/VoxelShapeArray.java
index caf297fe977942ca68fdb963d97dd9fc0f78d883..3161e3b9772e911991a5106615afdd10858b8452 100644
--- a/src/main/java/net/minecraft/server/VoxelShapeArray.java
+++ b/src/main/java/net/minecraft/server/VoxelShapeArray.java
@@ -11,7 +11,7 @@ public final class VoxelShapeArray extends VoxelShape {
     private final DoubleList d;
 
     protected VoxelShapeArray(VoxelShapeDiscrete voxelshapediscrete, double[] adouble, double[] adouble1, double[] adouble2) {
-        this(voxelshapediscrete, (DoubleList) DoubleArrayList.wrap(Arrays.copyOf(adouble, voxelshapediscrete.b() + 1)), (DoubleList) DoubleArrayList.wrap(Arrays.copyOf(adouble1, voxelshapediscrete.c() + 1)), (DoubleList) DoubleArrayList.wrap(Arrays.copyOf(adouble2, voxelshapediscrete.d() + 1)));
+        this(voxelshapediscrete, com.tuinity.tuinity.util.fastutil.ExtendedDoubleArrayList.getList(adouble, voxelshapediscrete.b() + 1), com.tuinity.tuinity.util.fastutil.ExtendedDoubleArrayList.getList(adouble1, voxelshapediscrete.c() + 1), com.tuinity.tuinity.util.fastutil.ExtendedDoubleArrayList.getList(adouble2, voxelshapediscrete.d() + 1)); // Tuinity - remove iterator allocation
     }
 
     VoxelShapeArray(VoxelShapeDiscrete voxelshapediscrete, DoubleList doublelist, DoubleList doublelist1, DoubleList doublelist2) {
diff --git a/src/main/java/net/minecraft/server/VoxelShapeCubePoint.java b/src/main/java/net/minecraft/server/VoxelShapeCubePoint.java
index 9e09671dc24cfcd3bfe872cacdeb0a5d7e83c112..b69a1ed46a0a90a22fa1223613a43aac8ec4072a 100644
--- a/src/main/java/net/minecraft/server/VoxelShapeCubePoint.java
+++ b/src/main/java/net/minecraft/server/VoxelShapeCubePoint.java
@@ -2,7 +2,7 @@ package net.minecraft.server;
 
 import it.unimi.dsi.fastutil.doubles.AbstractDoubleList;
 
-public class VoxelShapeCubePoint extends AbstractDoubleList {
+public class VoxelShapeCubePoint extends com.tuinity.tuinity.util.fastutil.ExtendedAbstractDoubleList { // Tuinity - remove iterator allocation
 
     private final int a;
 
diff --git a/src/main/java/net/minecraft/server/VoxelShapeMergerList.java b/src/main/java/net/minecraft/server/VoxelShapeMergerList.java
index 71d2ae2a9c5a05351241b5a313e66ca15b0624ef..9129eaa6422f695e1408e4227420f4c71438d05a 100644
--- a/src/main/java/net/minecraft/server/VoxelShapeMergerList.java
+++ b/src/main/java/net/minecraft/server/VoxelShapeMergerList.java
@@ -18,7 +18,7 @@ public final class VoxelShapeMergerList implements VoxelShapeMerger {
         int l = doublelist1.size();
         int i1 = k + l;
 
-        this.a = new DoubleArrayList(i1);
+        this.a = new com.tuinity.tuinity.util.fastutil.ExtendedDoubleArrayList(i1); // Tuinity - remove iterator creation
         this.b = new IntArrayList(i1);
         this.c = new IntArrayList(i1);
 
diff --git a/src/main/java/net/minecraft/server/VoxelShapes.java b/src/main/java/net/minecraft/server/VoxelShapes.java
index 08c83c62dfe875600162a46a0ca4b835b0bfe199..d5da9f582558356c128c9543aac5dac2325e6167 100644
--- a/src/main/java/net/minecraft/server/VoxelShapes.java
+++ b/src/main/java/net/minecraft/server/VoxelShapes.java
@@ -19,7 +19,7 @@ public final class VoxelShapes {
         return new VoxelShapeCube(voxelshapebitset);
     });
     public static final VoxelShape a = create(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
-    private static final VoxelShape c = new VoxelShapeArray(new VoxelShapeBitSet(0, 0, 0), new DoubleArrayList(new double[]{0.0D}), new DoubleArrayList(new double[]{0.0D}), new DoubleArrayList(new double[]{0.0D}));
+    private static final VoxelShape c = new VoxelShapeArray(new VoxelShapeBitSet(0, 0, 0), new com.tuinity.tuinity.util.fastutil.ExtendedDoubleArrayList(new double[]{0.0D}), new com.tuinity.tuinity.util.fastutil.ExtendedDoubleArrayList(new double[]{0.0D}), new com.tuinity.tuinity.util.fastutil.ExtendedDoubleArrayList(new double[]{0.0D})); // Tuinity - remove iterator allocation
 
     public static VoxelShape a() {
         return VoxelShapes.c;
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 2ee9f09e77c15c0f2843bc70c12ac055e6bff592..a90c5b9cebeea71dff6892f976f8133c81c7a8ca 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -55,7 +55,7 @@ public class WorldServer extends World {
 
     private static final Logger LOGGER = LogManager.getLogger();
     private final List<Entity> globalEntityList = Lists.newArrayList();
-    public final Int2ObjectMap<Entity> entitiesById = new Int2ObjectLinkedOpenHashMap();
+    public final Int2ObjectMap<Entity> entitiesById = new Int2ObjectLinkedOpenHashMap(); // Tuinity - diff on change, we expect Int2ObjectLinkedOpenHashMap
     private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
     private final Queue<Entity> entitiesToAdd = Queues.newArrayDeque();
     public final List<EntityPlayer> players = Lists.newArrayList(); // Paper - private -> public
@@ -465,7 +465,7 @@ public class WorldServer extends World {
 
             gameprofilerfiller.exitEnter("regular");
             this.tickingEntities = true;
-            ObjectIterator objectiterator = this.entitiesById.int2ObjectEntrySet().iterator();
+            ObjectIterator objectiterator = ((Int2ObjectLinkedOpenHashMap)this.entitiesById).int2ObjectEntrySet().fastIterator(); // Tuinity - use fast iterator to reduce entry creation
 
             org.spigotmc.ActivationRange.activateEntities(this); // Spigot
             timings.entityTick.startTiming(); // Spigot
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 051506fce81728ad46eede0b63448fab86be314e..35507262b6d6b34d054868510c2ec0b4f45b1a2d 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -291,9 +291,9 @@ public class CraftWorld implements World {
     }
     public int getTileEntityCount() {
         // We don't use the full world tile entity list, so we must iterate chunks
-        Long2ObjectLinkedOpenHashMap<PlayerChunk> chunks = world.getChunkProvider().playerChunkMap.visibleChunks;
+        Iterable<PlayerChunk> chunks = world.getChunkProvider().playerChunkMap.chunkMap.getVisibleValues(); // Tuinity - replace chunk map
         int size = 0;
-        for (net.minecraft.server.PlayerChunk playerchunk : chunks.values()) {
+        for (net.minecraft.server.PlayerChunk playerchunk : chunks) { // Tuinity - replace chunk map
             net.minecraft.server.Chunk chunk = playerchunk.getChunk();
             if (chunk == null) {
                 continue;
@@ -308,7 +308,7 @@ public class CraftWorld implements World {
     public int getChunkCount() {
         int ret = 0;
 
-        for (PlayerChunk chunkHolder : world.getChunkProvider().playerChunkMap.visibleChunks.values()) {
+        for (PlayerChunk chunkHolder : world.getChunkProvider().playerChunkMap.chunkMap.getVisibleValues()) { // Tuinity - replace chunk map
             if (chunkHolder.getChunk() != null) {
                 ++ret;
             }
@@ -432,8 +432,8 @@ public class CraftWorld implements World {
 
     @Override
     public Chunk[] getLoadedChunks() {
-        Long2ObjectLinkedOpenHashMap<PlayerChunk> chunks = world.getChunkProvider().playerChunkMap.visibleChunks;
-        return chunks.values().stream().map(PlayerChunk::getFullChunk).filter(Objects::nonNull).map(net.minecraft.server.Chunk::getBukkitChunk).toArray(Chunk[]::new);
+        Collection<PlayerChunk> chunks = world.getChunkProvider().playerChunkMap.chunkMap.getVisibleValues(); // Tuinity - replace chunk map
+        return chunks.stream().map(PlayerChunk::getFullChunk).filter(Objects::nonNull).map(net.minecraft.server.Chunk::getBukkitChunk).toArray(Chunk[]::new); // Tuinity - replace chunk map
     }
 
     @Override
